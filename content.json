{"meta":{"title":"codingの鹿先生","subtitle":"","description":"","author":"John Doe","url":"https://calvinhwang123.github.io"},"pages":[],"posts":[{"title":"Spring Boot 日志","slug":"spring-boot-logging","date":"2018-12-05T16:00:00.000Z","updated":"2018-12-09T11:04:32.238Z","comments":true,"path":"2018/12/06/spring-boot-logging/","link":"","permalink":"https://calvinhwang123.github.io/2018/12/06/spring-boot-logging/","excerpt":"一、日志门面与日志实现市场上存在非常多的日志框架，如：JUL(java.util.logging)、JCL(Apache Commons Logging)、Log4j、Log4j2、Logback、slf4j和jboss-logging等。spring-boot-starter-logging 采用了 slf4j + logback 的形式，Spring Boot 也能自动配置 (JUL, log4j2, logback) 并简化配置。","text":"一、日志门面与日志实现市场上存在非常多的日志框架，如：JUL(java.util.logging)、JCL(Apache Commons Logging)、Log4j、Log4j2、Logback、slf4j和jboss-logging等。spring-boot-starter-logging 采用了 slf4j + logback 的形式，Spring Boot 也能自动配置 (JUL, log4j2, logback) 并简化配置。 以上几款日志框架分为日志门面与日志实现，关系大致如下： 日志门面 日志实现 JCL, slf4j, jboss-logging JUL, log4j, log4j2, logback 二、Spring Boot 默认日志实现我们新建一个最简单 Spring Boot Maven 工程，使用 IDEA 生成 Maven 依赖树如下： 我们可以看到，spring-boot-start 依赖了 spring-boot-start-logging ，而不管是 log4j ，jul 还是 logback，最终都实现了 slf4j 门面。 对于如何将 log4j， jul 等转换为 slf4 实现，可以参考 slf4j 官网 Spring 框架默认使用 JCL Spring Boot 选用的门面与实现是 slf4j 和 logback Spring Boot 能自动适配所有的日志，而且底层使用的是 slf4j + logback 的方式记录日志，引入其他框架的时候，只要把这个框架依赖的日志框架排除掉即可。 三、Spring Boot 中日志使用1、日志级别Spring Boot slf4j 共有 5 个级别的日志输出，从低到高分别为：track, debug, info, warn, error。默认输出的级别为 info，采用由低到高的过滤方式，因此可以输出的级别为 info, warn 和 error。 2、修改默认日志配置我们可以在 application.propertites 内修改日志配置 如图，我们可以修改指定 package 下日志输出级别。 默认情况下，日志只能在 console 上呈现输出，如果要实现日志的永久保存，我们可以考虑以文件方式存储。使用 logging.file 和 logging.path 来指定文件名和日志路径（一般两个配置不混用） 四、本文 Demo占位符 五、参考文献 尚硅谷 Spring Boot 核心技术篇 官网","categories":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://calvinhwang123.github.io/categories/Spring-Boot/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://calvinhwang123.github.io/tags/Spring-Boot/"}]},{"title":"Spring Boot 自动配置","slug":"spring-boot-auto-config","date":"2018-11-29T16:00:00.000Z","updated":"2018-12-04T15:53:02.755Z","comments":true,"path":"2018/11/30/spring-boot-auto-config/","link":"","permalink":"https://calvinhwang123.github.io/2018/11/30/spring-boot-auto-config/","excerpt":"一、@EnableAutoConfiguration 与自动配置@EnableAutoConfiguration 是 @AutoConfigurationPackage 和 @Import(AutoConfigurationImportSelector.class)的混合注解。","text":"一、@EnableAutoConfiguration 与自动配置@EnableAutoConfiguration 是 @AutoConfigurationPackage 和 @Import(AutoConfigurationImportSelector.class)的混合注解。 其中，@AutoConfigurationPackage 通过导入一个 AutoConfigurationPackages.Registrar 注册类为程序指定了自动配置的包范围为：XXXApplication 所在包及其子包，如果一个类位于XXXApplication 所在包之外，是不会被 Spring Boot 自动配置的。 @Import(AutoConfigurationImportSelector.class) 导入的AutoConfigurationImportSelector 作为自动配置选择器，在程序运行时决定导入哪些自动配置类，即形如 XXXAutoConfiguraion 的自动配置类。 在 AutoConfigurationImportSelector 的 getCandidateConfigurations() 方法中，我们可以看到通过一个 SpringFactoriesLoader 去返回 configurations 数组，我们来看 loadFactoryNames() 方法： 我们发现 classLoader 加载自动配置资源的路径为： 1public static final String FACTORIES_RESOURCE_LOCATION = \"META-INF/spring.factories\"; 打开该文件如下： 为了验证 Spring Boot 就是从该 spring.factories 文件加载 自动配置的，我们 F6 一下返回configurations 数组： 通过调试我们可以得出结论：Spring Boot 通过 @EnableAutoConfiguration 注解读取spring.factories 文件，完成了默认自动配置功能，这些自动配置类会在容器中生效，省去开发者手动配置的麻烦。 二、 配置文件与 YAML2.1 全局配置文件Spring Boot 全局配置文件命名为 application.properties 或者 application.yml. 配置文件可以放在 src/main/resources 或者类路径/config 下，当然还有其他位置，只是加载的顺序不同。 使用配置文件可以对一些默认自动配置的值进行修改，如 context-path、port 等。 2.2 YAML.yml 是 YAML (YAML Ain’t Markup Language) 语言的文件，以数据为中心，比 JSON、XML 等更适合做配置文件。YAML具体的语法规范可以参考官网 2.2.1 YAML 基本语法 使用缩进进行层级关系，键值对之间必须带空格 缩进时不允许使用 TAB 键，只允许 Space 即空格键 缩进空格数量不重要，相同层级元素左对齐即可。（约定俗成使用 2 个空格） 大小写敏感 2.2.2 支持三种数据结构 对象：键值对的集合，或者称为 MAP 数组：一组按次序排列的值 字面量：包括字符串，数字，布尔值和日期等 2.2.3 属性值注入例子以下我们通过 @ConfigurationProperties 和 @Value 分别实现从配置文件读取属性注入到程序中。 首先创建实体类 Person 和 Dog 123456789101112131415161718192021public class Dog &#123; private String name; private Integer age; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950@Component@ConfigurationProperties(prefix = \"person\")public class Person &#123; private String name; private Boolean isBoss; private Map&lt;String, Object&gt; map; private List&lt;Object&gt; list; private Dog dog; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Boolean getBoss() &#123; return isBoss; &#125; public void setBoss(Boolean boss) &#123; isBoss = boss; &#125; public Map&lt;String, Object&gt; getMap() &#123; return map; &#125; public void setMap(Map&lt;String, Object&gt; map) &#123; this.map = map; &#125; public List&lt;Object&gt; getList() &#123; return list; &#125; public void setList(List&lt;Object&gt; list) &#123; this.list = list; &#125; public Dog getDog() &#123; return dog; &#125; public void setDog(Dog dog) &#123; this.dog = dog; &#125;&#125; 在我们添加 @ConfigurationProperties 注解时，IDEA 智能提示我们尚未导入 spring-boot-configuration-processor 依赖。所以在 pom.xml 下加入 这里先以 properties 文件写入属性值 123456789101112server.port=8081server.servlet.context-path=/helloperson.name=张三person.boss=falseperson.birthday=1995/01/01person.map.k1=v1person.map.k2=100person.map.k3=trueperson.list=1,true,helloperson.dog.name=Rookieperson.dog.age=2 最后在 test 包下进行测试 123456789101112131415@RunWith(SpringRunner.class)@SpringBootTestpublic class ApplicationTests &#123; @Autowired private Person person; @Test public void contextLoads() &#123; System.out.println(person); &#125;&#125; debug 运行后得到如下结果 相应的 yml 格式如下 123456789person: name: 李四 boss: true birthday: 2000/1/1 map: &#123; k1: v1, k2: 100, k3: false &#125; list: 1, java, 你好, false dog: name: Tom age: 1 以上演示的是 list 的行内写法，缩进写法如下 12345list: - 1 - Java - 你好 - false 我们注意到 application.properties 或 application.yml 都是全局配置文件，person 应该写在一个独立的 person.properties 比较合适，所以我们新建一个 properties 文件，并且为 Person 加上一个注解 @PropertySource 指定资源路径 1234@Component@ConfigurationProperties(prefix = \"person\")@PropertySource(value = \"classpath:person.properties\") // 这里 person.yml 可以不？public class Person &#123;&#125; 然后测试一下 可以看到虽然属性值成功注入到 Person 组件了，但是从 properties 文件读取的值出现了中文乱码。这是由于 IDEA 使用 UTF-8 作为字符集，但是 properties 写入文件存的是 ASCII 编码，所以需要修改 IDEA properties 设置 重新编写 properties 文件，再次运行，发现乱码得到解决 我们也可以使用 @Value 注解实现属性值的注入 如果我们只是在某个业务逻辑中需要获取以下配置文件中的某项值，使用 @Value 就可以了，如果专门写了一个 JavaBean 来和配置文件映射，直接使用 @ConfigurationProperties 会方便很多。 2.3 多 Profile 文件我们在编写主配置文件时，文件名可以是 application-{profile}-properties/yml 默认使用的是 application.properties/yml 为了更方便的切换，我们可以使用 yml 的多文档块方式 — 1234567891011121314151617181920212223server: port: 8080 # 默认端口spring: profiles: active: dev # 激活开发环境 ---server: port: 8081spring: profiles: dev # 指定是开发环境 ---server: port: 8082spring: profiles: test # 指定是测试环境---server: port: 8083spring: profiles: prod # 指定是生产环境 三、加载顺序Spring Boot 启动会扫描以下位置的 application.properties 或者 application.yml 文件作为 Spring Boot 的默认配置文件： file:./config/ file:./ classpath:/config/ classpath:/ 以上是按照优先级从高到低的顺序，所有位置的文件都会被加载，高优先 级配置内容会覆盖低优先级配置内容。 我们也可以通过配置spring.config.location来改变默认配置。 以下我们通过简单例子来论证以上观点。 我们在四个文件都指定了 server port ，分别为 8081，8082，8083 和 8084，而最后生效的是 8081，这说明 Spring Boot 优先加载 file:./config 下的配置文件 四、配置原理1、可以查看HttpEncodingAutoConfiguration 2、通用模式 – xxxAutoConfiguration：自动配置类 – xxxProperties：属性配置类 – yml/properties文件中能配置的值就来源于[属性配置类] 3、几个重要注解 – @Bean – @Conditional 4、–debug=true 查看详细的自动配置报告 精髓 1）、Spring Boot 启动会加载大量的自动配置类 2）、我们看我们需要的功能有没有 Spring Boot 默认写好的自动配置类；3）、我们再来看这个自动配置类中到底配置了哪些组件；（只要我们要用的组件有，我们就不需要再来配置了） 4）、给容器中自动配置类添加组件的时候，会从 properties 类中获取某些属性。我们就可以在配置文件中指定这 些属性的值； @Conditional 扩展 @Conditional扩展注解 作用（判断是否满足当前指定条件） @ConditionalOnJava 系统的java版本是否符合要求 @ConditionalOnBean 容器中存在指定Bean @ConditionalOnMissingBean 容器中不存在指定Bean @ConditionalOnExpression 满足SpEL表达式指定 @ConditionalOnClass 系统中有指定的类 @ConditionalOnMissingClass 系统中没有指定的类 @ConditionalOnSingleCandidate 容器中只有一个指定的Bean，或者这个Bean是首选Bean @ConditionalOnProperty 系统中指定的属性是否有指定的值 @ConditionalOnResource 类路径下是否存在指定资源文件 @ConditionalOnWebApplication 当前是web环境 @ConditionalOnNotWebApplication 当前不是web环境 @ConditionalOnJndi JNDI存在指定项 五、本文 Demo占位符 六、参考文献 尚硅谷 Spring Boot 核心技术篇 官网","categories":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://calvinhwang123.github.io/categories/Spring-Boot/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://calvinhwang123.github.io/tags/Spring-Boot/"}]},{"title":"第一个 Spring Boot APP","slug":"first-spring-boot-application","date":"2018-11-28T16:00:00.000Z","updated":"2018-12-04T12:00:58.764Z","comments":true,"path":"2018/11/29/first-spring-boot-application/","link":"","permalink":"https://calvinhwang123.github.io/2018/11/29/first-spring-boot-application/","excerpt":"一、Spring Boot 简介1、产生背景Java EE 开发笨重、配置繁多、开发效率低下、部署流程复杂、第三方技术集成难度大","text":"一、Spring Boot 简介1、产生背景Java EE 开发笨重、配置繁多、开发效率低下、部署流程复杂、第三方技术集成难度大 2、解决方案 Spring 全家桶时代。通过 Spring MVC 处理控制层，Spring 事务管理处理业务层，Spring Data 处理持久层，Spring 拥有一套完整的企业级 Java WEB 应用开发的解决方案。 Spring Boot。目标是提供 Java EE 一站式解决方案。 Spring Cloud。目标是提供分布式整体解决方案。（微服务架构风格） 3、优势 快速创建独立运行的Spring项目以及与主流框架集成 –&gt; 各种 starter，暂且称为 场景启动器 使用嵌入式的Servlet容器（默认支持 Tomcat，Jetty 和 Undertow，也可自定义），应用无需打成WAR包（可以打成 jar 包并使用内置 WEB 容器运行） starters自动依赖与版本控制 大量的自动配置，简化开发，也可修改默认值 无需配置XML，无代码生成，开箱即用 准生产环境的运行时应用监控 – 与云计算的天然集成 4、拓展：微服务架构风格详见 微服务架构的倡导者 Martin Fowler 个人网站 微服务架构风格介绍 简而言之，微服务架构风格是将单个应用程序开发为一套小型服务的方法，每个小型服务都在自己的流程中运行，并与轻量级机制（通常是HTTP资源API）进行通信。这些服务围绕业务功能构建，可通过全自动部署机制独立部署。这些服务至少集中管理，可以用不同的编程语言编写，并使用不同的数据存储技术。——詹姆斯刘易斯和马丁福勒 In short, the microservice architectural style is an approach to developing a single application as a suite of small services, each running in its own process and communicating with lightweight mechanisms, often an HTTP resource API. These services are built around business capabilities and independently deployable by fully automated deployment machinery. There is a bare minimum of centralized management of these services, which may be written in different programming languages and use different data storage technologies. – James Lewis and Martin Fowler 5、总说Spring Boot 是 Pivotal 团队推出的 Java 开发框架。Spring Boot 使得开发者更轻易地开发出基于 Spring 的独立运行、生产级别的 WEB 应用。Spring Boot 为开发者整合了主流的第三方库，通过极少的配置，就能构建出一款企业级应用。 总的说，Spring Boot 是用来简化 Spring应用开发，本着 约定大于配置 的原则，去繁从简， just run as spring boot app ,就能创建一个独立的，产品级别的应用。 二、入门小 Demo1、开发环境 JDK 1.8 MAVEN 3.x IDEA 2017.2.2 或 STS 3.9.x Spring Boot 1.5.x 或 Spring Boot 2.1.0 Spring Boot 2.1.x 要求 JDK 1.8+，Spring 5.1.x+，Tomcat 9，可以根据实际情况选用 Spring Boot 1.5.x 或者 Spring Boot 2.1.x 2、IDEA 问个好 以下是基于个人喜好修改的几项 IDEA 配置，觉得有用的可以参考下 IDEA Preferences 首先是 New Project，前提是配置好了 Project SDK，即 JDK，并且保证在联网的环境下。 其次是填写 Project Metadata，我们选择 Maven 工程，IDEA 将为我们生成 pom.xml 文件构建 Maven 工程。使用 Java 开发，package 方式为 jar 包。package 包名如果觉得过长可以修改下。 然后选择我们要添加的 dependences。因为我们是 WEB 入门小 demo，所以选择 web 依赖即可。Spring Boot 版本可以根据自身需要选择 2.x 或者 1.5x。 最后是确认项目名称和项目路径，然后点 finish 完成。 以下是基于 IDEA MAVEN 构建的 Spring Boot 工程，如果略带强迫症的患者可以删除选中的几项无用配置文件 打开 pom.xml 文件，可以看到一个最简的 Spring Boot 引入了 starter-web 和 starter-test 两个依赖，还有一个 maven-plugin 插件（用于编译maven工程） 在 pom.xml 文件内部，右键 diagrams 可以查看项目依赖树 既然我们编写的是 WEB 应用，需要编写 controller 层处理客户端请求 1234567891011HelloController.java@RestControllerpublic class HelloController &#123; @GetMapping(&#123;&quot;/&quot;, &quot;/hello&quot;&#125;) public String greeting() &#123; return &quot;Hello Spring Boot&quot;; &#125;&#125; 可以看到 Spring Boot 已经为我们创建了一个形如 XXXApplication 的启动类，带有 @SpringBootApplication 注解，并且有一个 main 方法。 选择 IDEA main 方法左侧运行图标，以 run 方式启动 在 console 中除了看到 Spring Boot 绚丽的图标外，我们看到应用已经运行在内置的Tomcat 的 8080 端口上了。 最后是通过 Chrome 等浏览器访问 WEB 服务。可以看到 localhost:8080/ 和 localhost:8080/hello 被我们的 HelloController 处理了。 当然我们也可以使用 PostMan 工具模拟客户端请求，测试一下。 3、STS 问个好File / New / Spring Starter Project 填写好 project 相关信息，Next 还是选择 web dependency 就好，然后点击 finish 以下是 STS 构建的 Spring Boot 工程。 同样编写一个 HelloController 用于处理前端请求。 STS 运行 Spring Boot 应用的方式为：右键 Application 启动类，Run As / Spring Boot App。 在 console 上可以看到 应用已经运行起来了。 使用浏览器测试。 4、以 java -jar 方式运行以下以 IDEA 为例演示 Spring Boot Maven jar 工程的打包，cmd 方式运行 WEB 应用。 调出 Maven 面板 找到 compile ，双击它 compile 成功后，IEDA 在 target 目录下为我们生成了 project_name.jar 可执行 jar 包 右键它，选择面板中的 show in explorer，在 Windows 的资源管理器路径下输入 cmd 三个字母 最后在 cmd 下执行java -jar project_name.jar ，前提是停止了 IDEA 运行的 web 工程，否则会出现端口占用的问题。 由以上可见，我们使用 java -jar 命令也能在 cmd 上运行 jar 应用。 三、Spring Boot 入口类探究1、入口类程序从 main 方法开始执行，默认使用 SpringApplication.run() 加载主程序类 2、@SpringBootApplication实际上是个组合注解： 123456@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan(excludeFilters = &#123; @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class), @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)public @interface SpringBootApplication &#123;&#125; 2.1 @SpringBootConfiguration其中，@SpringBootConfiguration 表示是 Spring 底层配置类，如下： 12@Configurationpublic @interface SpringBootConfiguration &#123;&#125; 2.2 @ComponentScan@ComponentScan 是个组件扫描注解 2.3 @EnableAutoConfiguration@EnableAutoConfiguration 是一个核心注解，表示允许 Spring Boot 完成自动配置功能 123@AutoConfigurationPackage@Import(AutoConfigurationImportSelector.class)public @interface EnableAutoConfiguration &#123;&#125; 2.3.1 @AutoConfigurationPackage其中 @AutoConfigurationPackage 通过导入一个 AutoConfigurationPackages.Registrar 注册类为程序指定了自动配置的包范围 12@Import(AutoConfigurationPackages.Registrar.class)public @interface AutoConfigurationPackage &#123;&#125; 由此可见，程序启动会扫描加载主程序类所在的包以及子包。这说明如果一个包位于主程序类所在包之外，是不会被 Spring 容器扫描实例化的。以下是简单的例子： AnotherController 位于 com.shinedeer.springboot 包之外 通过浏览器访问 localhost:8080/another 请求，结果返回 404。 2.3.2 @Import(AutoConfigurationImportSelector.class)@Import 作用是导入所有自动配置场景 AutoConfigurationImportSelector 会给容器中导入非常多的自动配置类，形如 XXXAutoConfiguration ，就是给容器中导入 starter 需要的组件并进行配置。 四、相关 Demo 本文 Demo 占位符 Spring Boot Official Samples Github 五、参考文献 Spring Boot 官方 reference 官网 尚硅谷 Spring Boot 核心技术篇 官网 ​ ​","categories":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://calvinhwang123.github.io/categories/Spring-Boot/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://calvinhwang123.github.io/tags/Spring-Boot/"}]}]}