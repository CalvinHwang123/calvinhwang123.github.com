{"meta":{"title":"codingの鹿先生","subtitle":"","description":"","author":"John Doe","url":"https://calvinhwang123.github.io"},"pages":[],"posts":[{"title":"Spring Boot 登录拦截器","slug":"spring-boot-login-interceptor","date":"2018-12-10T16:00:00.000Z","updated":"2018-12-11T14:57:19.282Z","comments":true,"path":"2018/12/11/spring-boot-login-interceptor/","link":"","permalink":"https://calvinhwang123.github.io/2018/12/11/spring-boot-login-interceptor/","excerpt":"一、准备工作首先确保工程引入了 starter-web 和 thymeleaf 依赖。","text":"一、准备工作首先确保工程引入了 starter-web 和 thymeleaf 依赖。 1、编写自定义 web mvc 配置类该配置类的作用是自定义请求映射与页面跳转。（注意 Spring Boot 2 是 implements WebMvcConfigurer） 12345678910@Configurationpublic class MyMvcConfig implements WebMvcConfigurer &#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; registry.addViewController(\"/\").setViewName(\"login\"); registry.addViewController(\"/index.html\").setViewName(\"login\"); registry.addViewController(\"/main.html\").setViewName(\"dashboard\"); &#125;&#125; 2、编写 login.html 登录页1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"&gt; &lt;head&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1, shrink-to-fit=no\"&gt; &lt;meta name=\"description\" content=\"\"&gt; &lt;meta name=\"author\" content=\"\"&gt; &lt;title&gt;Signin Template for Bootstrap&lt;/title&gt; &lt;!-- Bootstrap core CSS --&gt; &lt;link th:href=\"@&#123; /asserts/css/bootstrap.min.css &#125;\" rel=\"stylesheet\"&gt; &lt;!-- Custom styles for this template --&gt; &lt;link th:href=\"@&#123; /asserts/css/signin.css &#125;\" rel=\"stylesheet\"&gt; &lt;/head&gt; &lt;body class=\"text-center\"&gt; &lt;form class=\"form-signin\" action=\"dashboard.html\" method=\"post\" th:action=\"@&#123; /user/login &#125;\"&gt; &lt;img class=\"mb-4\" th:src=\"$&#123; /asserts/img/bootstrap-solid.svg &#125;\" alt=\"\" width=\"72\" height=\"72\"&gt; &lt;h1 class=\"h3 mb-3 font-weight-normal\"&gt;Please sign in&lt;/h1&gt; &lt;!--登录信息反馈--&gt; &lt;p th:if=\"$&#123; not #strings.isEmpty(errorMsg) &#125;\" th:text=\"$&#123; errorMsg &#125;\" class=\"text-danger\"&gt;&lt;/p&gt; &lt;label class=\"sr-only\"&gt;Username&lt;/label&gt; &lt;input name=\"userName\" type=\"text\" class=\"form-control\" placeholder=\"Username\" required=\"\" autofocus=\"\"&gt; &lt;label class=\"sr-only\"&gt;Password&lt;/label&gt; &lt;input name=\"password\" type=\"password\" class=\"form-control\" placeholder=\"Password\" required=\"\"&gt; &lt;div class=\"checkbox mb-3\"&gt; &lt;label&gt; &lt;input type=\"checkbox\" value=\"remember-me\"&gt; Remember me &lt;/label&gt; &lt;/div&gt; &lt;button class=\"btn btn-lg btn-primary btn-block\" type=\"submit\"&gt;Sign in&lt;/button&gt; &lt;p class=\"mt-5 mb-3 text-muted\"&gt;© 2017-2018&lt;/p&gt; &lt;a class=\"btn btn-sm\"&gt;中文&lt;/a&gt; &lt;a class=\"btn btn-sm\"&gt;English&lt;/a&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; p.s. 为了使页面实时生效，我们需要在 application.properties 下添加禁用缓存 12# 开发模式下禁用缓存spring.thymeleaf.cache=false 并且为了防止 js, css 等资源请求跳转后访问不到，我们使用 th:href 和 th:src 等配合 @{} 表达式。 3、编写 LoginController123456789101112131415161718192021@RequestMapping(\"/user\")@Controllerpublic class LoginController &#123; @PostMapping(\"/login\") public String login(@RequestParam String userName, @RequestParam String password, HttpSession session, Map&lt;String, Object&gt; map) &#123; if (!StringUtils.isEmpty(userName) &amp;&amp; !StringUtils.isEmpty(password)) &#123; if (userName.equals(password)) &#123; session.setAttribute(\"userName\", userName); // 用户信息存入session 作用域 return \"dashboard\"; // 进入主页面板 &#125; &#125; map.put(\"errorMsg\", \"登录错误\"); return \"login\"; // 转发到登录页 // 由于我们要往登录页面传递反馈数据，所以不能用重定向 // return \"redirect:../index.html\"; // 重定向回登录页 &#125;&#125; 二、避免表单重复提交当我们进入主页后，再次刷新页面，可能会出现表单重复提交的现象。 我们可以使用重定向的方法，避免表单重复提交 123// return \"dashboard\"; // 进入主页面板// 为了避免表单重复提交，使用重定向return \"redirect:/main.html\"; 三、登录拦截虽然我们实现了 /user/login 请求映射到登录检查方法，但是我们直接访问 /main.html 也是可以进入主页的。所以我们需要实现登录验证。这里使用拦截器的方法实现登录验证。 1234567891011121314@Configurationpublic class LoginInterceptor implements HandlerInterceptor &#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; String userName = (String) request.getSession().getAttribute(\"userName\"); if (StringUtils.isEmpty(userName)) &#123; request.setAttribute(\"errorMsg\", \"没有权限登录\"); request.getRequestDispatcher(\"/index.html\").forward(request, response); return false; // 拦截请求 &#125; return true; // 放行 &#125;&#125; 然后在自定义 web mvc 配置类中注册拦截器，并且排除登录请求和静态资源请求。 1234567@Overridepublic void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(new LoginInterceptor()) .addPathPatterns(\"/**\") .excludePathPatterns(\"/\", \"/index.html\", \"/user/login\") .excludePathPatterns(\"/asserts/**\"); // 这里的 /asserts 是 static 目录下的根目录&#125; 四、验证当我们盗链访问网页时，会出现没有权限访问的字样。 当我们登录信息输入错误时，会回到登录界面，提示登录错误。 当我们成功登录后，会重定向进入主页面（避免表单重复提交）。 五、本文 Demo占位符 六、参考文献 尚硅谷 Spring Boot 核心技术篇 官网 springboot2.0+配置拦截器拦截静态资源的问题","categories":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://calvinhwang123.github.io/categories/Spring-Boot/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://calvinhwang123.github.io/tags/Spring-Boot/"}]},{"title":"Spring Boot 自定义错误数据","slug":"spring-boot-customize-error","date":"2018-12-10T16:00:00.000Z","updated":"2018-12-13T13:23:47.141Z","comments":true,"path":"2018/12/11/spring-boot-customize-error/","link":"","permalink":"https://calvinhwang123.github.io/2018/12/11/spring-boot-customize-error/","excerpt":"一、Spring Boot 默认错误处理机制1、浏览器访问浏览器返回一个默认的错误页面。","text":"一、Spring Boot 默认错误处理机制1、浏览器访问浏览器返回一个默认的错误页面。 2、移动端访问（PostMan模拟）移动端默认访问 json 数据 3、原理可以参照 ErrorMvcAutoConfiguration，错误处理的自动配置类。 ErrorMvcAutoConfiguration 给容器中添加了以下组件： DefaultErrorAttributes： BasicErrorController：处理默认的 /error 请求 ErrorPageCustomizer： DefaultErrorViewResolver： 步骤：一旦系统出现 4xx 或 5xx 之类的错误，ErrorPageCustomizer 就会生效（定制错误的响应规则），就会来到 /error 请求，被 BasicErrorController 处理。 二、如何定制错误响应1、定制错误页面如果是简单的定制错误页面，我们只需要在 templates 目录下，新建名为 error 的目录，再命名文件名为状态码即可，如 404.html。为了统一处理错误页面，我们可以只建立 4xx.html 和 5xx.html 的文件。 如果使用了 Thymeleaf 模板引擎，还可以取出 status， timestamp，error，exception 等错误信息。 2、自定义错误信息首先我们来编写自定义错误类 123456public class UserNotFoundException extends RuntimeException &#123; public UserNotFoundException() &#123; super(\"用户不存在\"); &#125;&#125; 然后自定义错误处理器 1234567891011121314151617181920212223242526@ControllerAdvicepublic class MyExceptionHandler &#123; // 这样子浏览器和移动端都是返回 json 数据 /*@ExceptionHandler(UserNotFoundException.class) @ResponseBody public Map&lt;String, Object&gt; handleException() &#123; Map&lt;String, Object&gt; errorMap = new HashMap&lt;&gt;(); errorMap.put(\"code\", \"notfound\"); errorMap.put(\"message\", \"找不到对象\"); return errorMap; &#125;*/ @ExceptionHandler(UserNotFoundException.class) public String handleException(HttpServletRequest request) &#123; request.setAttribute(\"javax.servlet.error.status_code\",500); Map&lt;String, Object&gt; errorMap = new HashMap&lt;&gt;(); errorMap.put(\"code\", \"notfound\"); errorMap.put(\"message\", \"找不到对象\"); request.setAttribute(\"extMap\", errorMap); return \"forward:/error\"; &#125;&#125; 我们在handleException() 方法中传入了 HttpServletRequest 参数，在指定了 status_code 的前提下，往 request 域中存放了 自定义错误信息，最后转发到 /error 请求。 接下来我们要做的是自定义 ErrorAttributes 类，并且注册成为 component。 1234567891011@Componentpublic class MyErrorAttributes extends DefaultErrorAttributes &#123; @Override public Map&lt;String, Object&gt; getErrorAttributes(WebRequest webRequest, boolean includeStackTrace) &#123; Map&lt;String, Object&gt; map = super.getErrorAttributes(webRequest, includeStackTrace); map.put(\"extMap\", webRequest.getAttribute(\"extMap\", WebRequest.SCOPE_REQUEST)); map.put(\"company\", \"闲鹿科技\"); return map; &#125;&#125; 这样子 ErrorMvcAutoConfiguration 也会把我们自定义的 attributes 放入 错误信息的 Map 中。 最后我们使用浏览器和 POSTMAN 测试一下。 我们发现浏览器响应的是自定义错误页面，POSTMAN 响应的是自定义错误 JSON 数据。 三、本文 Demo占位符 四、参考文献 尚硅谷 Spring Boot 核心技术篇 官网","categories":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://calvinhwang123.github.io/categories/Spring-Boot/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://calvinhwang123.github.io/tags/Spring-Boot/"}]},{"title":"Spring Boot 实现页面国际化","slug":"spring-boot-i18n","date":"2018-12-09T16:00:00.000Z","updated":"2018-12-11T14:52:47.613Z","comments":true,"path":"2018/12/10/spring-boot-i18n/","link":"","permalink":"https://calvinhwang123.github.io/2018/12/10/spring-boot-i18n/","excerpt":"一、效果图使用 Spring Boot 实现页面国际化非常简单，以下是实现的效果图：","text":"一、效果图使用 Spring Boot 实现页面国际化非常简单，以下是实现的效果图： 以下我们就针对 Spring Boot 2 和 Spring Boot 1.5 分别自定义 配置类实现页面国际化。 二、准备工作首先确保你新建的项目是 WEB 工程。我们以 IDEA 构建 MAVEN 工程为例。 以下是 pom.xml 配置，主要导入了 starter-web 和 thymeleaf 依赖。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.shinedeer&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-1-i18n&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;spring-boot-1-i18n&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.17.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;!--记得改成 thymeleaf 3+ layout 2+--&gt; &lt;thymeleaf.version&gt;3.0.9.RELEASE&lt;/thymeleaf.version&gt; &lt;!-- 布局功能的支持程序 thymeleaf3 主程序 layout2 以上版本 --&gt; &lt;!-- thymeleaf2 layout1--&gt; &lt;thymeleaf-layout-dialect.version&gt;2.2.2&lt;/thymeleaf-layout-dialect.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 其次是编写 .properties 文件实现国际化关键字的配置 使用 Spring Boot 实现国际化如此简单，主要是因为 MessageResourceAutoConfiguration 自动配置类为我们完成了国际化资源文件的加载与配置。 因此，我们在全局配置文件 application.properties (yml) 下添加自定义配置 这样子，MessageResourceAutoConfiguration 便会帮我们根据用户实时浏览器或操作系统语言去加载不同语言的配置文件 (siri_xx_XX.properties) 然后我们编写 Thymeleaf 语法驱动的 html 页面，这里使用到了 国际化表达式 #{ keyword } 和 URL 表达式 @{ url } 。具体的使用可以参照 Thymeleaf 文档。 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;[[#&#123; siri.title &#125;]]&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;a th:href=\"@&#123; /ask(lang='en_US') &#125;\"&gt;Siri&lt;/a&gt; &lt;a th:href=\"@&#123; /ask(lang='zh_CN') &#125;\"&gt;希瑞&lt;/a&gt; &lt;a th:href=\"@&#123; /ask(lang='zh_TW') &#125;\"&gt;希瑞(繁中)&lt;/a&gt; &lt;p th:text=\"#&#123; siri.ask &#125;\"&gt;&lt;/p&gt; &lt;p th:text=\"#&#123; siri.answer1 &#125;\"&gt;&lt;/p&gt; &lt;div style=\"height: 480px;\"&gt;&lt;/div&gt; &lt;p th:text=\"#&#123; siri.answer2 &#125;\"&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 由以上页面可知，我们使用 a 标签，附加 lang=语言标识 的请求参数的 GET 方法向后台提交切换语言的请求。 三、后台处理后台处理的思路是：通过自定义 LocaleResolver ，从 request 域 中取出语言标识，并实现对语言的重新设置与解析。然后再把自定义 LocalResolver 通过 @Bean 注解注入到自定义 mvc 配置类中。 只不过在自定义 mvc 配置类时候，Spring Boot2 不推荐使用 extends WebMvcConfigurerAdapter 的方式了。所以我们改用 implements WebMvcConfigurer 的方式自定义 mvc 配置类，注入 LocaleChangeInterceptor 拦截器实例，并且在 addInterceptors 方法中注册拦截器。 1、自定义 LocaleResolver 组件 2、Spring Boot 1.5 自定义 mvc 配置类 3、Spring Boot 2 自定义 mvc 配置类1234567891011121314151617181920212223242526272829/** * @author Calvin Hwang * 2018/11/26 19:30 * 实现 WebMvcConfigurer 接口的自定义配置类 */// @Configurationpublic class MyMvcConfig2 implements WebMvcConfigurer &#123; @Bean public LocaleResolver localeResolver() &#123; SessionLocaleResolver slr = new SessionLocaleResolver(); // slr.setDefaultLocale(Locale.US); // 这边在中文操作系统或者说中文浏览器下无效？ return slr; &#125; @Bean public LocaleChangeInterceptor localeChangeInterceptor() &#123; LocaleChangeInterceptor lci = new LocaleChangeInterceptor(); lci.setParamName(\"lang\"); return lci; &#125; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; registry.addViewController(\"/\").setViewName(\"index\"); registry.addViewController(\"/index.html\").setViewName(\"index\"); &#125; @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(localeChangeInterceptor()); &#125;&#125; 由于以上我们 在 Spring Boot 1.5 的 MyMvcConfig 类中重写了 addViewControllers 时使用 registry 添加了 /ask 路径映射与跳转，所以不需要编写 Controller 层即可实现简单国际化测试。Spring Boot 2 的自定义配置类同理不再赘述。 4、运行测试此时在浏览器运行测试，即可实现页面国际化切换。 四、本文 Demospring-boot-1-i18n spring-boot-2-i18n 五、参考文献 尚硅谷 Spring Boot 核心技术篇 官网 Guide to Internationalization in Spring Boot","categories":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://calvinhwang123.github.io/categories/Spring-Boot/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://calvinhwang123.github.io/tags/Spring-Boot/"}]},{"title":"Spring Boot 与 WEB 开发","slug":"spring-boot-web","date":"2018-12-09T16:00:00.000Z","updated":"2018-12-11T14:54:24.006Z","comments":true,"path":"2018/12/10/spring-boot-web/","link":"","permalink":"https://calvinhwang123.github.io/2018/12/10/spring-boot-web/","excerpt":"一、简介使用 Spring Boot 进行 WEB 开发，只需要进行以下三步：","text":"一、简介使用 Spring Boot 进行 WEB 开发，只需要进行以下三步： 创建 Spring Boot 应用，选中我们需要的模块； Spring Boot 已经默认将这些场景配置好了，只需要在配置文件中指定少量配置就可以运行起来； 自己编写业务代码。 如果我们要深入研究 Spring Boot 帮我们做了哪些工作，我们需要探究自动配置原理。可以从以下几个方面考虑： 这个场景 Spring Boot 帮我们配置了什么？ 能不能修改？能修改哪些配置？ 能不能扩展？… 要研究以上问题，一般从形如 xxxAutoConfiguraion 和 xxxProperties 两个类来考虑 其中，xxxAutoConfiguraion 帮我们给容器中自动配置组件；而 xxxProperties 配置类用于封装配置文件中的内容。 二、Spring Boot 对静态资源的映射规则 所有的 /webjars/**，都去 classpath:/META-INF/resources/webjars/ 找资源 webjars: 以 jar 包的方式引入静态资源 /** 访问当前项目的任何资源，都去静态资源的文件夹找映射 欢迎页：静态资源下的所有 index.html 页面，都被 /** 映射 所有的 **/favicon.ico 都在静态资源文件下找。 123456789101112131415161718192021222324252627@Overridepublic void addResourceHandlers(ResourceHandlerRegistry registry) &#123; if (!this.resourceProperties.isAddMappings()) &#123; logger.debug(\"Default resource handling disabled\"); return; &#125; Duration cachePeriod = this.resourceProperties.getCache().getPeriod(); CacheControl cacheControl = this.resourceProperties.getCache() .getCachecontrol().toHttpCacheControl(); // 验证第一点 if (!registry.hasMappingForPattern(\"/webjars/**\")) &#123; customizeResourceHandlerRegistration(registry .addResourceHandler(\"/webjars/**\") .addResourceLocations(\"classpath:/META-INF/resources/webjars/\") .setCachePeriod(getSeconds(cachePeriod)) .setCacheControl(cacheControl)); &#125; String staticPathPattern = this.mvcProperties.getStaticPathPattern(); if (!registry.hasMappingForPattern(staticPathPattern)) &#123; customizeResourceHandlerRegistration( registry.addResourceHandler(staticPathPattern) .addResourceLocations(getResourceLocations( this.resourceProperties.getStaticLocations())) // 验证第二点 .setCachePeriod(getSeconds(cachePeriod)) .setCacheControl(cacheControl)); &#125;&#125; 123456public class ResourceProperties &#123; // 验证第二点 private static final String[] CLASSPATH_RESOURCE_LOCATIONS = &#123; \"classpath:/META-INF/resources/\", \"classpath:/resources/\", \"classpath:/static/\", \"classpath:/public/\" &#125;;&#125; 12345678910private Optional&lt;Resource&gt; getWelcomePage() &#123; String[] locations = getResourceLocations( this.resourceProperties.getStaticLocations()); return Arrays.stream(locations).map(this::getIndexHtml) .filter(this::isReadable).findFirst();&#125;private Resource getIndexHtml(String location) &#123; return this.resourceLoader.getResource(location + \"index.html\"); // 验证第三点&#125; 123456789101112131415161718@Beanpublic SimpleUrlHandlerMapping faviconHandlerMapping() &#123; SimpleUrlHandlerMapping mapping = new SimpleUrlHandlerMapping(); mapping.setOrder(Ordered.HIGHEST_PRECEDENCE + 1); mapping.setUrlMap(Collections.singletonMap(\"**/favicon.ico\", faviconRequestHandler())); // 验证第四点 return mapping;&#125;private List&lt;Resource&gt; resolveFaviconLocations() &#123; String[] staticLocations = getResourceLocations( this.resourceProperties.getStaticLocations()); // 验证第四点 List&lt;Resource&gt; locations = new ArrayList&lt;&gt;(staticLocations.length + 1); Arrays.stream(staticLocations).map(this.resourceLoader::getResource) .forEach(locations::add); locations.add(new ClassPathResource(\"/\")); return Collections.unmodifiableList(locations);&#125; 三、模板引擎 ThymeleafWEB 开发中模板引擎有多种，如：JSP、Velocity、Freemarker 和 Thymeleaf。 虽然说模板引擎多种多样，但它们的原理是一样的。都是通过模板引擎将 模板 和 数据 加工成为 html 响应给浏览器。 Spring Boot 推荐的模板引擎是 Thymeleaf。 1、引入 Thymeleaf我们推荐使用 Thymeleaf 3。如果你的默认不是 Thymeleaf 3，可以通过以下配置切换： 12345&lt;!--记得改成 thymeleaf 3+ layout 2+--&gt;&lt;thymeleaf.version&gt;3.0.9.RELEASE&lt;/thymeleaf.version&gt;&lt;!-- 布局功能的支持程序 thymeleaf3主程序 layout2以上版本 --&gt;&lt;!-- thymeleaf2 layout1--&gt;&lt;thymeleaf-layout-dialect.version&gt;2.2.2&lt;/thymeleaf-layout-dialect.version&gt; 123456@ConfigurationProperties(prefix = \"spring.thymeleaf\")public class ThymeleafProperties &#123; private static final Charset DEFAULT_ENCODING = StandardCharsets.UTF_8; public static final String DEFAULT_PREFIX = \"classpath:/templates/\"; public static final String DEFAULT_SUFFIX = \".html\";&#125; 通过以上 ThymeleafProperties 配置类可知，我们需要把使用 Thymeleaf 语法的 html 页面放在 /templates/ 目录下。 2、使用 Thymeleaf123456789@RequestMapping(\"/hello\")@Controllerpublic class HelloController &#123; @GetMapping(\"/greeting\") public String greeting(Map&lt;String, Object&gt; map) &#123; map.put(\"name\", \"Calvin\"); return \"hello\"; &#125;&#125; 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;首页&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div th:text=\"$&#123; name &#125;\"&gt;你好&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 四、Spring MVC 自动配置原理可以参考官网 https://docs.spring.io/spring-boot/docs/2.1.1.RELEASE/reference/htmlsingle/#boot-features-spring-mvc-auto-configuration Spring Boot 自动配置好了 Spring MVC。 以下是 Spring Boot 通过 WebMvcAutoConfiguration 对 Spring MVC 的默认配置 包含了两个 bean： ContentNegotiatingViewResolver and BeanNameViewResolver. 自动配置了 ViewResolver (即视图解析器，根据方法的返回值得到视图对象，视图对象决定如何渲染，如转发，重定向)。 ContentNegotiatingViewResolver，组合所有的视图解析器 如何定制视图解析器：我们可以自己给容器中添加一个视图解析器，ContentNegotiatingViewResolver 会自动将其组合进来。 提供静态资源访问，包括 webjars。 自动注册了 of Converter, GenericConverter, and Formatter beans. Support for HttpMessageConverters (covered later in this document). Automatic registration of MessageCodesResolver (covered later in this document). 静态首页 index.html 支持. 自定义Favicon 图标支持(covered later in this document). Automatic use of a ConfigurableWebBindingInitializer bean (covered later in this document). If you want to keep Spring Boot MVC features and you want to add additional MVC configuration (interceptors, formatters, view controllers, and other features), you can add your own @Configuration class of type WebMvcConfigurer but without @EnableWebMvc. If you wish to provide custom instances of RequestMappingHandlerMapping, RequestMappingHandlerAdapter, or ExceptionHandlerExceptionResolver, you can declare a WebMvcRegistrationsAdapter instance to provide such components. If you want to take complete control of Spring MVC, you can add your own @Configuration annotated with @EnableWebMvc. 五、本文 Demo占位符 六、参考文献 尚硅谷 Spring Boot 核心技术篇 官网","categories":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://calvinhwang123.github.io/categories/Spring-Boot/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://calvinhwang123.github.io/tags/Spring-Boot/"}]},{"title":"Activiti 5.x 工作流","slug":"activiti-tutorial","date":"2018-12-06T16:00:00.000Z","updated":"2018-12-09T12:21:38.816Z","comments":true,"path":"2018/12/07/activiti-tutorial/","link":"","permalink":"https://calvinhwang123.github.io/2018/12/07/activiti-tutorial/","excerpt":"一、第一天 工作流技术绝对是找工作亮点，如果你会这个，“我”估计这工作百分之五十是成了。","text":"一、第一天 工作流技术绝对是找工作亮点，如果你会这个，“我”估计这工作百分之五十是成了。 1、Activiti 入门1-1 工作流概念以下是一段关于工作流概念的说明： 工作流(Workflow) 是 业务过程的部分或整体在计算机应用环境下的自动化，它主要解决了多个参与者之间按照某种预定义的规则传递文档、信息或任务的过程自动进行，从而实现某个预期的业务目标，或者促使此目标实现。 1-2 Activiti 介绍Activiti 5 是由 Alfresco 软件在 2010 年 5 月 17 日 发布的业务流程管理（BPM）框架，它是覆盖了业务流程管理、工作流、服务协作等领域的一个开源、灵活、易扩展的可执行流程语言框架。 1-3 工作流引擎ProcessEngine 对象是 Activiti 工作的核心，负责生成流程运行时的各种实例与数据、监控和管理流程的运行。 1-4 BPMNBusiness Process Model and Notation，业务流程建模与标注，描述流程的基本符号，包括这些图元如何组成一个业务流程图（Business Process Diagram） 1-5 数据库Activiti的后台是有数据库的支持，所有的表（23张）都以ACT_开头。 第二部分是表示表的用途的两个字母标识。 用途也和服务的API对应。 ACT_RE_*: ‘RE’表示repository。 这个前缀的表包含了流程定义和流程静态资源 （图片，规则，等等）。 ACT_RU_*: ‘RU’表示runtime。 这些运行时的表，包含流程实例，任务，变量，异步任务，等运行中的数据。 Activiti只在流程实例执行过程中保存这些数据， 在流程结束时就会删除这些记录。 这样运行时表可以一直很小，速度很快。 ACT_ID_*: ‘ID’表示identity。 这些表包含身份信息，比如用户，组等等。 ACT_HI_*: ‘HI’表示history。 这些表包含历史数据，比如历史流程实例， 变量，任务等等。 ACT_GE_*: 通用数据， 用于不同场景下，如存放资源文件。 1-6 Activiti 步骤简析1-6-1 定义工作流主要利用 IDE 生成两个文件 LeaveProcess.bpmn：给计算机进行流程的执行和信息的传递使用 LeaveProcess.png：给用户看的 1-6-2 执行和管理工作流 调用 Activiti 的 API 2、准备 Activiti 环境2-1 环境约束 JDK1.6 或者更高版本 支持的数据库有：h2, mysql, oracle, postgres, mssql, db2 等。 支持 activiti5 运行的 jar 包 开发环境为 Eclipse3.7 或者以上版本, myeclipse 为 8.6 版本 2-2 安装流程设计器（IDEA 插件）安装详情参考此文 IntelliJ IDEA安装Activiti插件并使用 3、第一章：Activiti 入门程序——Hello World3-1 使用 IDEA 创建 Maven 工程pom.xml 如下（可根据自身需要自己调节 version） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.shinedeer&lt;/groupId&gt; &lt;artifactId&gt;activiti-demo&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;properties&gt; &lt;spring.version&gt;4.1.4.RELEASE&lt;/spring.version&gt; &lt;mybatis.version&gt;3.2.8&lt;/mybatis.version&gt; &lt;mybatis-spring.version&gt;1.2.2&lt;/mybatis-spring.version&gt; &lt;junit.version&gt;4.12&lt;/junit.version&gt; &lt;activiti.version&gt;5.17.0&lt;/activiti.version&gt; &lt;log4j.version&gt;2.2&lt;/log4j.version&gt; &lt;mysql.version&gt;5.1.37&lt;/mysql.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- JUnit --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;$&#123;junit.version&#125;&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- Spring --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-orm&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- log4j --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-api&lt;/artifactId&gt; &lt;version&gt;$&#123;log4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-core&lt;/artifactId&gt; &lt;version&gt;$&#123;log4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mybatis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis-spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- activiti --&gt; &lt;dependency&gt; &lt;groupId&gt;org.activiti&lt;/groupId&gt; &lt;artifactId&gt;activiti-engine&lt;/artifactId&gt; &lt;version&gt;$&#123;activiti.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.activiti&lt;/groupId&gt; &lt;artifactId&gt;activiti-spring&lt;/artifactId&gt; &lt;version&gt;$&#123;activiti.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.activiti&lt;/groupId&gt; &lt;artifactId&gt;activiti-rest&lt;/artifactId&gt; &lt;version&gt;$&#123;activiti.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mysql database --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;$&#123;mysql.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;activitiDemo&lt;/finalName&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.2&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.7&lt;/source&gt; &lt;target&gt;1.7&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 3-2 使用 acitiviti.cfg.xml 创建 23 张表配置文件如下： 123456789101112131415161718&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsdhttp://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsdhttp://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd\"&gt; &lt;bean id=\"processEngineConfiguration\" class=\"org.activiti.engine.impl.cfg.StandaloneProcessEngineConfiguration\"&gt; &lt;!-- 连接数据的配置 --&gt; &lt;property name=\"jdbcDriver\" value=\"com.mysql.jdbc.Driver\"&gt;&lt;/property&gt; &lt;property name=\"jdbcUrl\" value=\"jdbc:mysql://localhost:3306/myactiviti?useUnicode=true&amp;amp;characterEncoding=utf8\"&gt;&lt;/property&gt; &lt;property name=\"jdbcUsername\" value=\"root\"&gt;&lt;/property&gt; &lt;property name=\"jdbcPassword\" value=\"root\"&gt;&lt;/property&gt; &lt;!-- 没有表创建表 --&gt; &lt;property name=\"databaseSchemaUpdate\" value=\"true\"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 3-3 创建数据库 myactiviti 3-4 编写测试类我们使用 ProcessEngine 配置类去加载 classpath 下的 配置文件，并构建出 ProcessEngine 对象。此时会系统会自动创建出 Activiti 流程需要的 23 张表。 运行通过后，再 F5 一下我们的数据库（别问我为什么是 24 张表，T^T，我只知道我 Maven 依赖的是 Activiti 5.17） 3-5 使用 actiBPM 插件绘制流程图确保我们已经安装了 IDEA 插件 actiBPM，依次 File / New / bpmnFile，新建一个 helloworld.bpmn 每一个工作流都有 StartEvent 和 EndEvent，并且至少有两个 UserTask。 我们使用以下操作来修改 bpmn 流程图：双击 UserTask 修改 name，鼠标悬浮 Event 或 Task 图标，当出现小人物图标是拖拽至下一个节点，即可出现连接线并完成连接，效果图如下： 然后我们选择某个 UserTask，在左侧 BPMN Editor 面板中，除了我们双击时修改的Name属性之外，还看到了一个 Assignee，表示代理人，被指定人，我们依次在三个 UserTask 的 Assignee 属性填写 张三，李四 和 王五。 我们再点击空白处，为整个 Process 的 id 和 name 属性赋值 最后再把 bpmn 文件 refactor / rename 成 xml 文件。并且 导出 png 图片 解决乱码问题 在 IDEA 安装路径下找到如下文件并添加 字符集 配置 最后重启 IDEA，可以解决 xml 和导出图片乱码问题 3-6 HelloWorld 模拟流程执行过程3-6-1 测试部署流程定义 数据库相关表也有了记录 3-6-2 测试流程实例 3-6-3 测试当前任务执行人 3-6-4 测试完成个人任务 从数据库表记录截图可以看到，当前办理人 张三 已经完成了任务，任务自然到了下一个办理人 部门经理。 我们如法炮制地执行 李四 和 王五 的任务，此时再查看 act_ru_task ，已经没有实时记录了，但是在 历史表中可以查看流程执行记录。 4、第二章：流程定义 CRUD4-1 使用 Zip 文件部署流程定义12345678910111213141516171819202122232425public class TestActiviti2 &#123; private ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine(); /** * 加载 zip 文件部署流程定义 */ @Test public void testDeploymentProcessDefinitionByZip() &#123; ZipInputStream inputStream = new ZipInputStream( getClass().getClassLoader() .getResourceAsStream(\"diagrams/helloworld.zip\")); Deployment deployment = processEngine.getRepositoryService() .createDeployment() .name(\"测试部署流程定义\") .addZipInputStream(inputStream) .deploy(); System.out.println(\"部署 id：\" + deployment.getId()); System.out.println(\"部署 name：\" + deployment.getName()); &#125;&#125; 4-2 查看流程定义1234567891011121314@Testpublic void testQueryProcessDefinition() &#123; List&lt;ProcessDefinition&gt; processDefinitionList = processEngine.getRepositoryService() .createProcessDefinitionQuery() .list(); for (ProcessDefinition processDefinition: processDefinitionList) &#123; System.out.println(\"流程定义 id：\" + processDefinition.getId()); System.out.println(\"流程定义 名称：\" + processDefinition.getName()); System.out.println(\"流程定义 KEY：\" + processDefinition.getKey()); System.out.println(\"流程定义 版本：\" + processDefinition.getVersion()); &#125;&#125; 4-3 删除流程定义12345@Testpublic void testDeleteProcessDefinition() &#123; processEngine.getRepositoryService() .deleteDeployment(\"1\", true);&#125; 5、第三章：流程实例、任务的执行参见 3-6 6、第四章：流程变量12345678910111213141516171819202122/** * 启动流程实例(并且 设置流程变量) */@Testpublic void startProcessInstance() &#123; Map&lt;String, Object&gt; variableMap = new HashMap&lt;&gt;(); variableMap.put(\"请假天数\", 3); variableMap.put(\"请假原因\", \"祖国未统一，心情很郁闷\"); variableMap.put(\"请假时间\", new Date()); processEngine.getRuntimeService() .startProcessInstanceByKey(\"helloworld\", variableMap);&#125;/** * 设置请假人 */@Testpublic void setAssignee() &#123; String taskId = \"5001\"; processEngine.getRuntimeService() .setVariable(taskId, \"请假人\", \"小明\");&#125; 7、第五章：查看历史记录12345678910111213@Testpublic void testQueryHistoryVariable() &#123; List&lt;HistoricVariableInstance&gt; list = processEngine.getHistoryService() .createHistoricVariableInstanceQuery() .variableName(\"请假人\") .list(); if (list != null &amp;&amp; list.size() &gt; 0) &#123; for (HistoricVariableInstance historicVariableInstance: list) &#123; System.out.println(\"变量名：\" + historicVariableInstance.getVariableName()); System.out.println(\"变量值：\" + historicVariableInstance.getValue()); &#125; &#125;&#125; 二、第二天1、第六章：连线2、第七章：活动节点（*）3、Activities 5.4 整合 SSH三、第三、四天1、项目实现 Activiti 工作流——请假流程管理系统四、本文Demo占位符 五、参考文献 传智播客 官网 IntelliJ IDEA安装Activiti插件并使用 Activiti + Spring开发环境搭建 Activiti 视频教程","categories":[{"name":"Activiti","slug":"Activiti","permalink":"https://calvinhwang123.github.io/categories/Activiti/"}],"tags":[{"name":"Activiti","slug":"Activiti","permalink":"https://calvinhwang123.github.io/tags/Activiti/"}]},{"title":"Spring Boot 日志","slug":"spring-boot-logging","date":"2018-12-05T16:00:00.000Z","updated":"2018-12-09T11:04:32.238Z","comments":true,"path":"2018/12/06/spring-boot-logging/","link":"","permalink":"https://calvinhwang123.github.io/2018/12/06/spring-boot-logging/","excerpt":"一、日志门面与日志实现市场上存在非常多的日志框架，如：JUL(java.util.logging)、JCL(Apache Commons Logging)、Log4j、Log4j2、Logback、slf4j和jboss-logging等。spring-boot-starter-logging 采用了 slf4j + logback 的形式，Spring Boot 也能自动配置 (JUL, log4j2, logback) 并简化配置。","text":"一、日志门面与日志实现市场上存在非常多的日志框架，如：JUL(java.util.logging)、JCL(Apache Commons Logging)、Log4j、Log4j2、Logback、slf4j和jboss-logging等。spring-boot-starter-logging 采用了 slf4j + logback 的形式，Spring Boot 也能自动配置 (JUL, log4j2, logback) 并简化配置。 以上几款日志框架分为日志门面与日志实现，关系大致如下： 日志门面 日志实现 JCL, slf4j, jboss-logging JUL, log4j, log4j2, logback 二、Spring Boot 默认日志实现我们新建一个最简单 Spring Boot Maven 工程，使用 IDEA 生成 Maven 依赖树如下： 我们可以看到，spring-boot-start 依赖了 spring-boot-start-logging ，而不管是 log4j ，jul 还是 logback，最终都实现了 slf4j 门面。 对于如何将 log4j， jul 等转换为 slf4 实现，可以参考 slf4j 官网 Spring 框架默认使用 JCL Spring Boot 选用的门面与实现是 slf4j 和 logback Spring Boot 能自动适配所有的日志，而且底层使用的是 slf4j + logback 的方式记录日志，引入其他框架的时候，只要把这个框架依赖的日志框架排除掉即可。 三、Spring Boot 中日志使用1、日志级别Spring Boot slf4j 共有 5 个级别的日志输出，从低到高分别为：track, debug, info, warn, error。默认输出的级别为 info，采用由低到高的过滤方式，因此可以输出的级别为 info, warn 和 error。 2、修改默认日志配置我们可以在 application.propertites 内修改日志配置 如图，我们可以修改指定 package 下日志输出级别。 默认情况下，日志只能在 console 上呈现输出，如果要实现日志的永久保存，我们可以考虑以文件方式存储。使用 logging.file 和 logging.path 来指定文件名和日志路径（一般两个配置不混用） 四、本文 Demo占位符 五、参考文献 尚硅谷 Spring Boot 核心技术篇 官网","categories":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://calvinhwang123.github.io/categories/Spring-Boot/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://calvinhwang123.github.io/tags/Spring-Boot/"}]},{"title":"Git 与 Github 基础","slug":"git-and-github","date":"2018-12-01T16:00:00.000Z","updated":"2018-12-09T12:01:24.560Z","comments":true,"path":"2018/12/02/git-and-github/","link":"","permalink":"https://calvinhwang123.github.io/2018/12/02/git-and-github/","excerpt":"以下记录自己安装 Git、使用 Git 基础命令向 Github 提交代码以及 IDEA 整合 Git 或 Github 的过程。","text":"以下记录自己安装 Git、使用 Git 基础命令向 Github 提交代码以及 IDEA 整合 Git 或 Github 的过程。 一、Git 软件1、安装 Git 软件进入 Git 官网，找到适合自己电脑操作系统的版本进行下载。 如果没有特殊需求，安装过程一路 Next 到底。 2、启动 git-bash 窗口如图。 2.1 设置全局 username 和 email。12git config --global user.name \"Your Name\"git config --global user.email \"email@example.com\" 2.2 创建版本库我们来到一个合适的地方（电脑磁盘路径啦），创建文件夹 learngit，并进入该文件夹 123mkdir learngitcd learngitpwd 2.3 初始化空仓库1git init 我们发现 learngit 文件夹多了一个 .git 的隐藏文件，现在它只是个空仓库 2.4 添加文件并提交使用 git add 命令添加文件，使用 git commit -m “提交注释说明” 12git add filename.扩展名git commit -m \"提交注释说明\" p.s. 我们使用 git commit 只是把文件提交到了本地仓库，以下内容介绍如何提交文件到远程仓库。 二、Github 远程仓库Github 是全球最大的代码管理平台，我们可以通过关联 Github 账号来实现 Git 提交文件到远程仓库。 3.1 创建远程仓库我们在 Github 网站上 new 一个同名的 remote repository. 根据创建远程仓库成功后的提示，我们使用以下命令提交文件到远程仓库 12git remote add origin git@github.com:yourusername/learngit.gitgit push -u origin master 如图所示，我们提交过程中可能出现提交失败的情况，这是因为手上的这台电脑并没有提交 RSA key 到 Github 上，认证失败了。 3.2 创建 RSA key在 git-bash 窗口，使用以下命令查看电脑是否存在 RSA key 12cd ~/.sshls 我们需要寻找一对以 id_dsa 或 id_rsa 命名的文件，其中一个带有 .pub 扩展名。 .pub 文件是你的公钥，另一个则是私钥。 如果找不到这样的文件（或者根本没有 .ssh 目录），表示你的电脑还没有生成密钥 使用 ssh-keygen命名生成 1ssh-keygen 该命令要求你输入两次密钥口令。如果你不想在使用密钥时输入口令，将其留空即可，可以直接按 enter 键生成 点击 Github 右上角图标，选择 settings / ssh and gpg keys / new ssh key 然后把 id_rsa.pub 内容添加到 Github 上即可。 3.3 提交到远程仓库现在再来使用 git remote add 和 git push 提交文件就没问题了。 3.4 从远程仓库克隆使用 git clone 克隆远程仓库 1git clone git@github.com:CalvinHwang123/learngit.git 三、IDEA 整合 Git3.1 配置 git.exe 路径在 IDEA 左上角工具栏，依次选择 file / other settings / default settings / version control / git 3.2 初始化本地仓库这里把项目所在 Project Location 初始化成本地仓库 3.3 创建 Github 远程仓库 3.4 在 IDEA 下使用 Git 操作项3.4.1 git add如图选中要提交的项目，右键 git / add，表示添加该项目到本地仓库 如果没有 git 操作项，则找到工具栏上方的 CVS / Enable Version Control Integration，选择 Git，此时再右键项目根目录就出现 Git 操作项了。 3.4.2 git commit使用 git commit 提交到本地仓库 3.4.3 配置 remote repository选择 git / repository / remores，然后填上 Github 远程仓库 HTTP 地址（注意不是 SSH，不可以吗？） 3.4.4 git push配置好 remote 地址，就可以把本地代码 推送到远程 Github 仓库了 F5 一下 Github 相应远程仓库，我们发现代码已经提交成功了。 四、使用 IDEA 从 Github 克隆项目在 IDEA 的启动面板选择 check out from version control，并选择 git 填好要 clone 的 HTTP 地址，点击 clone 因为我们要 clone 的是 maven 过程，所以选择 Import maven 选择具体的项目，不出意外一路 Next 我们 checkout 的是 Spring Boot 工程，不出意外如图所示成功运行 五、参考文献 廖雪峰 - Git 教程 Git 官网 完整教程–idea使用git进行项目管理","categories":[{"name":"GitHub","slug":"GitHub","permalink":"https://calvinhwang123.github.io/categories/GitHub/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://calvinhwang123.github.io/tags/Git/"},{"name":"GitHub","slug":"GitHub","permalink":"https://calvinhwang123.github.io/tags/GitHub/"}]},{"title":"Hexo + Github Pages 搭建博客","slug":"hexo-and-github-pages","date":"2018-12-01T16:00:00.000Z","updated":"2018-12-09T12:01:31.369Z","comments":true,"path":"2018/12/02/hexo-and-github-pages/","link":"","permalink":"https://calvinhwang123.github.io/2018/12/02/hexo-and-github-pages/","excerpt":"一、安装 Hexo安装 Hexo 相当简单。然而在安装前，您必须检查电脑中是否已安装下列应用程序： Node.js Git","text":"一、安装 Hexo安装 Hexo 相当简单。然而在安装前，您必须检查电脑中是否已安装下列应用程序： Node.js Git 所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。 1$ npm install -g hexo-cli 安装完成后 二、创建 Github Pages新建一个 repository，命名为 youraccount.github.com，然后点击 settings 挑选一款还行的 theme，点击完成。 访问 youraccount.github.io 看看效果（可能出现网络延迟，耐心等待效果~） 三、搭建本地 Hexo 服务器1、初始化 hexo在一个合适的目录下打开 git-bash 窗口 执行以下命令 1hexo init blog 我们后期写的博文都将以 markdown 格式编写，放在 source / _post 下 2、启动 Hexo 服务器我们执行以下命令将默认生成的 hello-world,md 博客发布在本地 Hexo 服务器上 1hexo s 然后 在浏览器输入 localhost:4000 测试一下 3、编写 md 博文把我们自己编写的博文放在 _post 目录下 F5 一下，新发布的博文就显示出来了 p.s. 还有些小问题，如目录，标题，样式等暂不考虑 四、自定义主题1、下载自定义主题Hexo 官网提供了很多优秀的 theme，有需要请戳 这里 。本文使用的主题是 material-x 打开终端，cd 到你博客的路径，下载主题到 themes/ 文件夹 1git clone https://github.com/xaoxuu/hexo-theme-material-x themes/material-x 然后在博客路径下安装依赖包 1npm i -S hexo-generator-search hexo-generator-feed hexo-renderer-less hexo-autoprefixer hexo-generator-json-content hexo-recommended-posts 2、修改 _config.yml修改 _config.yml ，使得自定义 theme 生效 3、切换为自定义主题1hexo.sh i x 如果提示 command not found ，说明你的电脑上还没有使用过 hexo.sh 脚本，那么可以执行下面这一段命令下载脚本然后应用主题： 1curl -O 'https://raw.githubusercontent.com/xaoxuu/hexo.sh/master/hexo.sh' 此时再 hexo s 一下，自定义主题就生效了。 4、生成博文1hexo g 五、发布到 Github Pages首先从 Github clone 下 Github Pages 将需要提交的文件夹从 本地 hexo 拷贝到 github pages 本地仓库 使用 git add 和 git commit 提交到本地仓库 使用 git push 推送到远程仓库 现在输入 https://calvinhwang123.github.io 访问一下 这样我们自定义主题就算完成了。 六、修改 Material X 主题配置在 themes / material-x / _config.yml 里这样一段说明 所以我们把配置搬到 blogpath / _config.yml 里面 以上的配置配合注释基本没什么问题。 还有一部分主题配置可以直接在 material-x 的 _config.yml 下设置，如：网易云歌单等。 七、使用 hexo-deployer-git 插件更新博客我们发现每次都手动往 Github Pages 更新博客太麻烦了，通过 hexo-deployer-git 插件可以方便地更新博客 七、参考文献 Hexo 官网 利用 githubpages 创建你的个人博客 Material X 如何搭建基于 Hexo 的独立博客","categories":[{"name":"GitHub","slug":"GitHub","permalink":"https://calvinhwang123.github.io/categories/GitHub/"}],"tags":[{"name":"GitHub","slug":"GitHub","permalink":"https://calvinhwang123.github.io/tags/GitHub/"},{"name":"Hexo","slug":"Hexo","permalink":"https://calvinhwang123.github.io/tags/Hexo/"}]},{"title":"Spring Boot 自动配置","slug":"spring-boot-auto-config","date":"2018-11-29T16:00:00.000Z","updated":"2018-12-04T15:53:02.755Z","comments":true,"path":"2018/11/30/spring-boot-auto-config/","link":"","permalink":"https://calvinhwang123.github.io/2018/11/30/spring-boot-auto-config/","excerpt":"一、@EnableAutoConfiguration 与自动配置@EnableAutoConfiguration 是 @AutoConfigurationPackage 和 @Import(AutoConfigurationImportSelector.class)的混合注解。","text":"一、@EnableAutoConfiguration 与自动配置@EnableAutoConfiguration 是 @AutoConfigurationPackage 和 @Import(AutoConfigurationImportSelector.class)的混合注解。 其中，@AutoConfigurationPackage 通过导入一个 AutoConfigurationPackages.Registrar 注册类为程序指定了自动配置的包范围为：XXXApplication 所在包及其子包，如果一个类位于XXXApplication 所在包之外，是不会被 Spring Boot 自动配置的。 @Import(AutoConfigurationImportSelector.class) 导入的AutoConfigurationImportSelector 作为自动配置选择器，在程序运行时决定导入哪些自动配置类，即形如 XXXAutoConfiguraion 的自动配置类。 在 AutoConfigurationImportSelector 的 getCandidateConfigurations() 方法中，我们可以看到通过一个 SpringFactoriesLoader 去返回 configurations 数组，我们来看 loadFactoryNames() 方法： 我们发现 classLoader 加载自动配置资源的路径为： 1public static final String FACTORIES_RESOURCE_LOCATION = \"META-INF/spring.factories\"; 打开该文件如下： 为了验证 Spring Boot 就是从该 spring.factories 文件加载 自动配置的，我们 F6 一下返回configurations 数组： 通过调试我们可以得出结论：Spring Boot 通过 @EnableAutoConfiguration 注解读取spring.factories 文件，完成了默认自动配置功能，这些自动配置类会在容器中生效，省去开发者手动配置的麻烦。 二、 配置文件与 YAML2.1 全局配置文件Spring Boot 全局配置文件命名为 application.properties 或者 application.yml. 配置文件可以放在 src/main/resources 或者类路径/config 下，当然还有其他位置，只是加载的顺序不同。 使用配置文件可以对一些默认自动配置的值进行修改，如 context-path、port 等。 2.2 YAML.yml 是 YAML (YAML Ain’t Markup Language) 语言的文件，以数据为中心，比 JSON、XML 等更适合做配置文件。YAML具体的语法规范可以参考官网 2.2.1 YAML 基本语法 使用缩进进行层级关系，键值对之间必须带空格 缩进时不允许使用 TAB 键，只允许 Space 即空格键 缩进空格数量不重要，相同层级元素左对齐即可。（约定俗成使用 2 个空格） 大小写敏感 2.2.2 支持三种数据结构 对象：键值对的集合，或者称为 MAP 数组：一组按次序排列的值 字面量：包括字符串，数字，布尔值和日期等 2.2.3 属性值注入例子以下我们通过 @ConfigurationProperties 和 @Value 分别实现从配置文件读取属性注入到程序中。 首先创建实体类 Person 和 Dog 123456789101112131415161718192021public class Dog &#123; private String name; private Integer age; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950@Component@ConfigurationProperties(prefix = \"person\")public class Person &#123; private String name; private Boolean isBoss; private Map&lt;String, Object&gt; map; private List&lt;Object&gt; list; private Dog dog; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Boolean getBoss() &#123; return isBoss; &#125; public void setBoss(Boolean boss) &#123; isBoss = boss; &#125; public Map&lt;String, Object&gt; getMap() &#123; return map; &#125; public void setMap(Map&lt;String, Object&gt; map) &#123; this.map = map; &#125; public List&lt;Object&gt; getList() &#123; return list; &#125; public void setList(List&lt;Object&gt; list) &#123; this.list = list; &#125; public Dog getDog() &#123; return dog; &#125; public void setDog(Dog dog) &#123; this.dog = dog; &#125;&#125; 在我们添加 @ConfigurationProperties 注解时，IDEA 智能提示我们尚未导入 spring-boot-configuration-processor 依赖。所以在 pom.xml 下加入 这里先以 properties 文件写入属性值 123456789101112server.port=8081server.servlet.context-path=/helloperson.name=张三person.boss=falseperson.birthday=1995/01/01person.map.k1=v1person.map.k2=100person.map.k3=trueperson.list=1,true,helloperson.dog.name=Rookieperson.dog.age=2 最后在 test 包下进行测试 123456789101112131415@RunWith(SpringRunner.class)@SpringBootTestpublic class ApplicationTests &#123; @Autowired private Person person; @Test public void contextLoads() &#123; System.out.println(person); &#125;&#125; debug 运行后得到如下结果 相应的 yml 格式如下 123456789person: name: 李四 boss: true birthday: 2000/1/1 map: &#123; k1: v1, k2: 100, k3: false &#125; list: 1, java, 你好, false dog: name: Tom age: 1 以上演示的是 list 的行内写法，缩进写法如下 12345list: - 1 - Java - 你好 - false 我们注意到 application.properties 或 application.yml 都是全局配置文件，person 应该写在一个独立的 person.properties 比较合适，所以我们新建一个 properties 文件，并且为 Person 加上一个注解 @PropertySource 指定资源路径 1234@Component@ConfigurationProperties(prefix = \"person\")@PropertySource(value = \"classpath:person.properties\") // 这里 person.yml 可以不？public class Person &#123;&#125; 然后测试一下 可以看到虽然属性值成功注入到 Person 组件了，但是从 properties 文件读取的值出现了中文乱码。这是由于 IDEA 使用 UTF-8 作为字符集，但是 properties 写入文件存的是 ASCII 编码，所以需要修改 IDEA properties 设置 重新编写 properties 文件，再次运行，发现乱码得到解决 我们也可以使用 @Value 注解实现属性值的注入 如果我们只是在某个业务逻辑中需要获取以下配置文件中的某项值，使用 @Value 就可以了，如果专门写了一个 JavaBean 来和配置文件映射，直接使用 @ConfigurationProperties 会方便很多。 2.3 多 Profile 文件我们在编写主配置文件时，文件名可以是 application-{profile}-properties/yml 默认使用的是 application.properties/yml 为了更方便的切换，我们可以使用 yml 的多文档块方式 — 1234567891011121314151617181920212223server: port: 8080 # 默认端口spring: profiles: active: dev # 激活开发环境 ---server: port: 8081spring: profiles: dev # 指定是开发环境 ---server: port: 8082spring: profiles: test # 指定是测试环境---server: port: 8083spring: profiles: prod # 指定是生产环境 三、加载顺序Spring Boot 启动会扫描以下位置的 application.properties 或者 application.yml 文件作为 Spring Boot 的默认配置文件： file:./config/ file:./ classpath:/config/ classpath:/ 以上是按照优先级从高到低的顺序，所有位置的文件都会被加载，高优先 级配置内容会覆盖低优先级配置内容。 我们也可以通过配置spring.config.location来改变默认配置。 以下我们通过简单例子来论证以上观点。 我们在四个文件都指定了 server port ，分别为 8081，8082，8083 和 8084，而最后生效的是 8081，这说明 Spring Boot 优先加载 file:./config 下的配置文件 四、配置原理1、可以查看HttpEncodingAutoConfiguration 2、通用模式 – xxxAutoConfiguration：自动配置类 – xxxProperties：属性配置类 – yml/properties文件中能配置的值就来源于[属性配置类] 3、几个重要注解 – @Bean – @Conditional 4、–debug=true 查看详细的自动配置报告 精髓 1）、Spring Boot 启动会加载大量的自动配置类 2）、我们看我们需要的功能有没有 Spring Boot 默认写好的自动配置类；3）、我们再来看这个自动配置类中到底配置了哪些组件；（只要我们要用的组件有，我们就不需要再来配置了） 4）、给容器中自动配置类添加组件的时候，会从 properties 类中获取某些属性。我们就可以在配置文件中指定这 些属性的值； @Conditional 扩展 @Conditional扩展注解 作用（判断是否满足当前指定条件） @ConditionalOnJava 系统的java版本是否符合要求 @ConditionalOnBean 容器中存在指定Bean @ConditionalOnMissingBean 容器中不存在指定Bean @ConditionalOnExpression 满足SpEL表达式指定 @ConditionalOnClass 系统中有指定的类 @ConditionalOnMissingClass 系统中没有指定的类 @ConditionalOnSingleCandidate 容器中只有一个指定的Bean，或者这个Bean是首选Bean @ConditionalOnProperty 系统中指定的属性是否有指定的值 @ConditionalOnResource 类路径下是否存在指定资源文件 @ConditionalOnWebApplication 当前是web环境 @ConditionalOnNotWebApplication 当前不是web环境 @ConditionalOnJndi JNDI存在指定项 五、本文 Demo占位符 六、参考文献 尚硅谷 Spring Boot 核心技术篇 官网","categories":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://calvinhwang123.github.io/categories/Spring-Boot/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://calvinhwang123.github.io/tags/Spring-Boot/"}]},{"title":"第一个 Spring Boot APP","slug":"first-spring-boot-application","date":"2018-11-28T16:00:00.000Z","updated":"2018-12-04T12:00:58.764Z","comments":true,"path":"2018/11/29/first-spring-boot-application/","link":"","permalink":"https://calvinhwang123.github.io/2018/11/29/first-spring-boot-application/","excerpt":"一、Spring Boot 简介1、产生背景Java EE 开发笨重、配置繁多、开发效率低下、部署流程复杂、第三方技术集成难度大","text":"一、Spring Boot 简介1、产生背景Java EE 开发笨重、配置繁多、开发效率低下、部署流程复杂、第三方技术集成难度大 2、解决方案 Spring 全家桶时代。通过 Spring MVC 处理控制层，Spring 事务管理处理业务层，Spring Data 处理持久层，Spring 拥有一套完整的企业级 Java WEB 应用开发的解决方案。 Spring Boot。目标是提供 Java EE 一站式解决方案。 Spring Cloud。目标是提供分布式整体解决方案。（微服务架构风格） 3、优势 快速创建独立运行的Spring项目以及与主流框架集成 –&gt; 各种 starter，暂且称为 场景启动器 使用嵌入式的Servlet容器（默认支持 Tomcat，Jetty 和 Undertow，也可自定义），应用无需打成WAR包（可以打成 jar 包并使用内置 WEB 容器运行） starters自动依赖与版本控制 大量的自动配置，简化开发，也可修改默认值 无需配置XML，无代码生成，开箱即用 准生产环境的运行时应用监控 – 与云计算的天然集成 4、拓展：微服务架构风格详见 微服务架构的倡导者 Martin Fowler 个人网站 微服务架构风格介绍 简而言之，微服务架构风格是将单个应用程序开发为一套小型服务的方法，每个小型服务都在自己的流程中运行，并与轻量级机制（通常是HTTP资源API）进行通信。这些服务围绕业务功能构建，可通过全自动部署机制独立部署。这些服务至少集中管理，可以用不同的编程语言编写，并使用不同的数据存储技术。——詹姆斯刘易斯和马丁福勒 In short, the microservice architectural style is an approach to developing a single application as a suite of small services, each running in its own process and communicating with lightweight mechanisms, often an HTTP resource API. These services are built around business capabilities and independently deployable by fully automated deployment machinery. There is a bare minimum of centralized management of these services, which may be written in different programming languages and use different data storage technologies. – James Lewis and Martin Fowler 5、总说Spring Boot 是 Pivotal 团队推出的 Java 开发框架。Spring Boot 使得开发者更轻易地开发出基于 Spring 的独立运行、生产级别的 WEB 应用。Spring Boot 为开发者整合了主流的第三方库，通过极少的配置，就能构建出一款企业级应用。 总的说，Spring Boot 是用来简化 Spring应用开发，本着 约定大于配置 的原则，去繁从简， just run as spring boot app ,就能创建一个独立的，产品级别的应用。 二、入门小 Demo1、开发环境 JDK 1.8 MAVEN 3.x IDEA 2017.2.2 或 STS 3.9.x Spring Boot 1.5.x 或 Spring Boot 2.1.0 Spring Boot 2.1.x 要求 JDK 1.8+，Spring 5.1.x+，Tomcat 9，可以根据实际情况选用 Spring Boot 1.5.x 或者 Spring Boot 2.1.x 2、IDEA 问个好 以下是基于个人喜好修改的几项 IDEA 配置，觉得有用的可以参考下 IDEA Preferences 首先是 New Project，前提是配置好了 Project SDK，即 JDK，并且保证在联网的环境下。 其次是填写 Project Metadata，我们选择 Maven 工程，IDEA 将为我们生成 pom.xml 文件构建 Maven 工程。使用 Java 开发，package 方式为 jar 包。package 包名如果觉得过长可以修改下。 然后选择我们要添加的 dependences。因为我们是 WEB 入门小 demo，所以选择 web 依赖即可。Spring Boot 版本可以根据自身需要选择 2.x 或者 1.5x。 最后是确认项目名称和项目路径，然后点 finish 完成。 以下是基于 IDEA MAVEN 构建的 Spring Boot 工程，如果略带强迫症的患者可以删除选中的几项无用配置文件 打开 pom.xml 文件，可以看到一个最简的 Spring Boot 引入了 starter-web 和 starter-test 两个依赖，还有一个 maven-plugin 插件（用于编译maven工程） 在 pom.xml 文件内部，右键 diagrams 可以查看项目依赖树 既然我们编写的是 WEB 应用，需要编写 controller 层处理客户端请求 1234567891011HelloController.java@RestControllerpublic class HelloController &#123; @GetMapping(&#123;&quot;/&quot;, &quot;/hello&quot;&#125;) public String greeting() &#123; return &quot;Hello Spring Boot&quot;; &#125;&#125; 可以看到 Spring Boot 已经为我们创建了一个形如 XXXApplication 的启动类，带有 @SpringBootApplication 注解，并且有一个 main 方法。 选择 IDEA main 方法左侧运行图标，以 run 方式启动 在 console 中除了看到 Spring Boot 绚丽的图标外，我们看到应用已经运行在内置的Tomcat 的 8080 端口上了。 最后是通过 Chrome 等浏览器访问 WEB 服务。可以看到 localhost:8080/ 和 localhost:8080/hello 被我们的 HelloController 处理了。 当然我们也可以使用 PostMan 工具模拟客户端请求，测试一下。 3、STS 问个好File / New / Spring Starter Project 填写好 project 相关信息，Next 还是选择 web dependency 就好，然后点击 finish 以下是 STS 构建的 Spring Boot 工程。 同样编写一个 HelloController 用于处理前端请求。 STS 运行 Spring Boot 应用的方式为：右键 Application 启动类，Run As / Spring Boot App。 在 console 上可以看到 应用已经运行起来了。 使用浏览器测试。 4、以 java -jar 方式运行以下以 IDEA 为例演示 Spring Boot Maven jar 工程的打包，cmd 方式运行 WEB 应用。 调出 Maven 面板 找到 compile ，双击它 compile 成功后，IEDA 在 target 目录下为我们生成了 project_name.jar 可执行 jar 包 右键它，选择面板中的 show in explorer，在 Windows 的资源管理器路径下输入 cmd 三个字母 最后在 cmd 下执行java -jar project_name.jar ，前提是停止了 IDEA 运行的 web 工程，否则会出现端口占用的问题。 由以上可见，我们使用 java -jar 命令也能在 cmd 上运行 jar 应用。 三、Spring Boot 入口类探究1、入口类程序从 main 方法开始执行，默认使用 SpringApplication.run() 加载主程序类 2、@SpringBootApplication实际上是个组合注解： 123456@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan(excludeFilters = &#123; @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class), @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)public @interface SpringBootApplication &#123;&#125; 2.1 @SpringBootConfiguration其中，@SpringBootConfiguration 表示是 Spring 底层配置类，如下： 12@Configurationpublic @interface SpringBootConfiguration &#123;&#125; 2.2 @ComponentScan@ComponentScan 是个组件扫描注解 2.3 @EnableAutoConfiguration@EnableAutoConfiguration 是一个核心注解，表示允许 Spring Boot 完成自动配置功能 123@AutoConfigurationPackage@Import(AutoConfigurationImportSelector.class)public @interface EnableAutoConfiguration &#123;&#125; 2.3.1 @AutoConfigurationPackage其中 @AutoConfigurationPackage 通过导入一个 AutoConfigurationPackages.Registrar 注册类为程序指定了自动配置的包范围 12@Import(AutoConfigurationPackages.Registrar.class)public @interface AutoConfigurationPackage &#123;&#125; 由此可见，程序启动会扫描加载主程序类所在的包以及子包。这说明如果一个包位于主程序类所在包之外，是不会被 Spring 容器扫描实例化的。以下是简单的例子： AnotherController 位于 com.shinedeer.springboot 包之外 通过浏览器访问 localhost:8080/another 请求，结果返回 404。 2.3.2 @Import(AutoConfigurationImportSelector.class)@Import 作用是导入所有自动配置场景 AutoConfigurationImportSelector 会给容器中导入非常多的自动配置类，形如 XXXAutoConfiguration ，就是给容器中导入 starter 需要的组件并进行配置。 四、相关 Demo 本文 Demo 占位符 Spring Boot Official Samples Github 五、参考文献 Spring Boot 官方 reference 官网 尚硅谷 Spring Boot 核心技术篇 官网 ​ ​","categories":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://calvinhwang123.github.io/categories/Spring-Boot/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://calvinhwang123.github.io/tags/Spring-Boot/"}]}]}