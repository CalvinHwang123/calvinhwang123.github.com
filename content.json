{"meta":{"title":"codingの鹿先生","subtitle":"","description":"","author":"John Doe","url":"https://calvinhwang123.github.io"},"pages":[],"posts":[{"title":"Spring Boot 日志","slug":"spring-boot-logging","date":"2018-12-05T16:00:00.000Z","updated":"2018-12-09T11:04:32.238Z","comments":true,"path":"2018/12/06/spring-boot-logging/","link":"","permalink":"https://calvinhwang123.github.io/2018/12/06/spring-boot-logging/","excerpt":"一、日志门面与日志实现市场上存在非常多的日志框架，如：JUL(java.util.logging)、JCL(Apache Commons Logging)、Log4j、Log4j2、Logback、slf4j和jboss-logging等。spring-boot-starter-logging 采用了 slf4j + logback 的形式，Spring Boot 也能自动配置 (JUL, log4j2, logback) 并简化配置。","text":"一、日志门面与日志实现市场上存在非常多的日志框架，如：JUL(java.util.logging)、JCL(Apache Commons Logging)、Log4j、Log4j2、Logback、slf4j和jboss-logging等。spring-boot-starter-logging 采用了 slf4j + logback 的形式，Spring Boot 也能自动配置 (JUL, log4j2, logback) 并简化配置。 以上几款日志框架分为日志门面与日志实现，关系大致如下： 日志门面 日志实现 JCL, slf4j, jboss-logging JUL, log4j, log4j2, logback 二、Spring Boot 默认日志实现我们新建一个最简单 Spring Boot Maven 工程，使用 IDEA 生成 Maven 依赖树如下： 我们可以看到，spring-boot-start 依赖了 spring-boot-start-logging ，而不管是 log4j ，jul 还是 logback，最终都实现了 slf4j 门面。 对于如何将 log4j， jul 等转换为 slf4 实现，可以参考 slf4j 官网 Spring 框架默认使用 JCL Spring Boot 选用的门面与实现是 slf4j 和 logback Spring Boot 能自动适配所有的日志，而且底层使用的是 slf4j + logback 的方式记录日志，引入其他框架的时候，只要把这个框架依赖的日志框架排除掉即可。 三、Spring Boot 中日志使用1、日志级别Spring Boot slf4j 共有 5 个级别的日志输出，从低到高分别为：track, debug, info, warn, error。默认输出的级别为 info，采用由低到高的过滤方式，因此可以输出的级别为 info, warn 和 error。 2、修改默认日志配置我们可以在 application.propertites 内修改日志配置 如图，我们可以修改指定 package 下日志输出级别。 默认情况下，日志只能在 console 上呈现输出，如果要实现日志的永久保存，我们可以考虑以文件方式存储。使用 logging.file 和 logging.path 来指定文件名和日志路径（一般两个配置不混用） 四、本文 Demo占位符 五、参考文献 尚硅谷 Spring Boot 核心技术篇 官网","categories":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://calvinhwang123.github.io/categories/Spring-Boot/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://calvinhwang123.github.io/tags/Spring-Boot/"}]},{"title":"Git 与 Github 基础","slug":"git-and-github","date":"2018-12-01T16:00:00.000Z","updated":"2018-12-09T11:46:55.110Z","comments":true,"path":"2018/12/02/git-and-github/","link":"","permalink":"https://calvinhwang123.github.io/2018/12/02/git-and-github/","excerpt":"以下记录自己安装 Git、使用 Git 基础命令向 Github 提交代码以及 IDEA 整合 Git 或 Github 的过程。","text":"以下记录自己安装 Git、使用 Git 基础命令向 Github 提交代码以及 IDEA 整合 Git 或 Github 的过程。 一、Git 软件1、安装 Git 软件进入 Git 官网，找到适合自己电脑操作系统的版本进行下载。 如果没有特殊需求，安装过程一路 Next 到底。 2、启动 git-bash 窗口如图。 2.1 设置全局 username 和 email。12git config --global user.name \"Your Name\"git config --global user.email \"email@example.com\" 2.2 创建版本库我们来到一个合适的地方（电脑磁盘路径啦），创建文件夹 learngit，并进入该文件夹 123mkdir learngitcd learngitpwd 2.3 初始化空仓库1git init 我们发现 learngit 文件夹多了一个 .git 的隐藏文件，现在它只是个空仓库 2.4 添加文件并提交使用 git add 命令添加文件，使用 git commit -m “提交注释说明” 12git add filename.扩展名git commit -m \"提交注释说明\" p.s. 我们使用 git commit 只是把文件提交到了本地仓库，以下内容介绍如何提交文件到远程仓库。 二、Github 远程仓库Github 是全球最大的代码管理平台，我们可以通过关联 Github 账号来实现 Git 提交文件到远程仓库。 3.1 创建远程仓库我们在 Github 网站上 new 一个同名的 remote repository. 根据创建远程仓库成功后的提示，我们使用以下命令提交文件到远程仓库 12git remote add origin git@github.com:yourusername/learngit.gitgit push -u origin master 如图所示，我们提交过程中可能出现提交失败的情况，这是因为手上的这台电脑并没有提交 RSA key 到 Github 上，认证失败了。 3.2 创建 RSA key在 git-bash 窗口，使用以下命令查看电脑是否存在 RSA key 12cd ~/.sshls 我们需要寻找一对以 id_dsa 或 id_rsa 命名的文件，其中一个带有 .pub 扩展名。 .pub 文件是你的公钥，另一个则是私钥。 如果找不到这样的文件（或者根本没有 .ssh 目录），表示你的电脑还没有生成密钥 使用 ssh-keygen命名生成 1ssh-keygen 该命令要求你输入两次密钥口令。如果你不想在使用密钥时输入口令，将其留空即可，可以直接按 enter 键生成 点击 Github 右上角图标，选择 settings / ssh and gpg keys / new ssh key 然后把 id_rsa.pub 内容添加到 Github 上即可。 3.3 提交到远程仓库现在再来使用 git remote add 和 git push 提交文件就没问题了。 3.4 从远程仓库克隆使用 git clone 克隆远程仓库 1git clone git@github.com:CalvinHwang123/learngit.git 三、IDEA 整合 Git3.1 配置 git.exe 路径在 IDEA 左上角工具栏，依次选择 file / other settings / default settings / version control / git 3.2 初始化本地仓库这里把项目所在 Project Location 初始化成本地仓库 3.3 创建 Github 远程仓库 3.4 在 IDEA 下使用 Git 操作项3.4.1 git add如图选中要提交的项目，右键 git / add，表示添加该项目到本地仓库 如果没有 git 操作项，则找到工具栏上方的 CVS / Enable Version Control Integration，选择 Git，此时再右键项目根目录就出现 Git 操作项了。 3.4.2 git commit使用 git commit 提交到本地仓库 3.4.3 配置 remote repository选择 git / repository / remores，然后填上 Github 远程仓库 HTTP 地址（注意不是 SSH，不可以吗？） 3.4.4 git push配置好 remote 地址，就可以把本地代码 推送到远程 Github 仓库了 F5 一下 Github 相应远程仓库，我们发现代码已经提交成功了。 四、使用 IDEA 从 Github 克隆项目在 IDEA 的启动面板选择 check out from version control，并选择 git 填好要 clone 的 HTTP 地址，点击 clone 因为我们要 clone 的是 maven 过程，所以选择 Import maven 选择具体的项目，不出意外一路 Next 我们 checkout 的是 Spring Boot 工程，不出意外如图所示成功运行 五、参考文献 廖雪峰 - Git 教程 Git 官网 完整教程–idea使用git进行项目管理","categories":[{"name":"Git","slug":"Git","permalink":"https://calvinhwang123.github.io/categories/Git/"},{"name":"GitHub","slug":"Git/GitHub","permalink":"https://calvinhwang123.github.io/categories/Git/GitHub/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://calvinhwang123.github.io/tags/Git/"},{"name":"GitHub","slug":"GitHub","permalink":"https://calvinhwang123.github.io/tags/GitHub/"}]},{"title":"Hexo + Github Pages 搭建博客","slug":"hexo-and-github-pages","date":"2018-12-01T16:00:00.000Z","updated":"2018-12-09T11:53:51.828Z","comments":true,"path":"2018/12/02/hexo-and-github-pages/","link":"","permalink":"https://calvinhwang123.github.io/2018/12/02/hexo-and-github-pages/","excerpt":"一、安装 Hexo安装 Hexo 相当简单。然而在安装前，您必须检查电脑中是否已安装下列应用程序： Node.js Git","text":"一、安装 Hexo安装 Hexo 相当简单。然而在安装前，您必须检查电脑中是否已安装下列应用程序： Node.js Git 所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。 1$ npm install -g hexo-cli 安装完成后 二、创建 Github Pages新建一个 repository，命名为 youraccount.github.com，然后点击 settings 挑选一款还行的 theme，点击完成。 访问 youraccount.github.io 看看效果（可能出现网络延迟，耐心等待效果~） 三、搭建本地 Hexo 服务器1、初始化 hexo在一个合适的目录下打开 git-bash 窗口 执行以下命令 1hexo init blog 我们后期写的博文都将以 markdown 格式编写，放在 source / _post 下 2、启动 Hexo 服务器我们执行以下命令将默认生成的 hello-world,md 博客发布在本地 Hexo 服务器上 1hexo s 然后 在浏览器输入 localhost:4000 测试一下 3、编写 md 博文把我们自己编写的博文放在 _post 目录下 F5 一下，新发布的博文就显示出来了 p.s. 还有些小问题，如目录，标题，样式等暂不考虑 四、自定义主题1、下载自定义主题Hexo 官网提供了很多优秀的 theme，有需要请戳 这里 。本文使用的主题是 material-x 打开终端，cd 到你博客的路径，下载主题到 themes/ 文件夹 1git clone https://github.com/xaoxuu/hexo-theme-material-x themes/material-x 然后在博客路径下安装依赖包 1npm i -S hexo-generator-search hexo-generator-feed hexo-renderer-less hexo-autoprefixer hexo-generator-json-content hexo-recommended-posts 2、修改 _config.yml修改 _config.yml ，使得自定义 theme 生效 3、切换为自定义主题1hexo.sh i x 如果提示 command not found ，说明你的电脑上还没有使用过 hexo.sh 脚本，那么可以执行下面这一段命令下载脚本然后应用主题： 1curl -O 'https://raw.githubusercontent.com/xaoxuu/hexo.sh/master/hexo.sh' 此时再 hexo s 一下，自定义主题就生效了。 4、生成博文1hexo g 五、发布到 Github Pages首先从 Github clone 下 Github Pages 将需要提交的文件夹从 本地 hexo 拷贝到 github pages 本地仓库 使用 git add 和 git commit 提交到本地仓库 使用 git push 推送到远程仓库 现在输入 https://calvinhwang123.github.io 访问一下 这样我们自定义主题就算完成了。 六、修改 Material X 主题配置在 themes / material-x / _config.yml 里这样一段说明 所以我们把配置搬到 blogpath / _config.yml 里面 以上的配置配合注释基本没什么问题。 还有一部分主题配置可以直接在 material-x 的 _config.yml 下设置，如：网易云歌单等。 七、使用 hexo-deployer-git 插件更新博客我们发现每次都手动往 Github Pages 更新博客太麻烦了，通过 hexo-deployer-git 插件可以方便地更新博客 七、参考文献 Hexo 官网 利用 githubpages 创建你的个人博客 Material X 如何搭建基于 Hexo 的独立博客","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://calvinhwang123.github.io/categories/Hexo/"},{"name":"GitHub","slug":"Hexo/GitHub","permalink":"https://calvinhwang123.github.io/categories/Hexo/GitHub/"}],"tags":[{"name":"GitHub","slug":"GitHub","permalink":"https://calvinhwang123.github.io/tags/GitHub/"},{"name":"Hexo","slug":"Hexo","permalink":"https://calvinhwang123.github.io/tags/Hexo/"}]},{"title":"Spring Boot 自动配置","slug":"spring-boot-auto-config","date":"2018-11-29T16:00:00.000Z","updated":"2018-12-04T15:53:02.755Z","comments":true,"path":"2018/11/30/spring-boot-auto-config/","link":"","permalink":"https://calvinhwang123.github.io/2018/11/30/spring-boot-auto-config/","excerpt":"一、@EnableAutoConfiguration 与自动配置@EnableAutoConfiguration 是 @AutoConfigurationPackage 和 @Import(AutoConfigurationImportSelector.class)的混合注解。","text":"一、@EnableAutoConfiguration 与自动配置@EnableAutoConfiguration 是 @AutoConfigurationPackage 和 @Import(AutoConfigurationImportSelector.class)的混合注解。 其中，@AutoConfigurationPackage 通过导入一个 AutoConfigurationPackages.Registrar 注册类为程序指定了自动配置的包范围为：XXXApplication 所在包及其子包，如果一个类位于XXXApplication 所在包之外，是不会被 Spring Boot 自动配置的。 @Import(AutoConfigurationImportSelector.class) 导入的AutoConfigurationImportSelector 作为自动配置选择器，在程序运行时决定导入哪些自动配置类，即形如 XXXAutoConfiguraion 的自动配置类。 在 AutoConfigurationImportSelector 的 getCandidateConfigurations() 方法中，我们可以看到通过一个 SpringFactoriesLoader 去返回 configurations 数组，我们来看 loadFactoryNames() 方法： 我们发现 classLoader 加载自动配置资源的路径为： 1public static final String FACTORIES_RESOURCE_LOCATION = \"META-INF/spring.factories\"; 打开该文件如下： 为了验证 Spring Boot 就是从该 spring.factories 文件加载 自动配置的，我们 F6 一下返回configurations 数组： 通过调试我们可以得出结论：Spring Boot 通过 @EnableAutoConfiguration 注解读取spring.factories 文件，完成了默认自动配置功能，这些自动配置类会在容器中生效，省去开发者手动配置的麻烦。 二、 配置文件与 YAML2.1 全局配置文件Spring Boot 全局配置文件命名为 application.properties 或者 application.yml. 配置文件可以放在 src/main/resources 或者类路径/config 下，当然还有其他位置，只是加载的顺序不同。 使用配置文件可以对一些默认自动配置的值进行修改，如 context-path、port 等。 2.2 YAML.yml 是 YAML (YAML Ain’t Markup Language) 语言的文件，以数据为中心，比 JSON、XML 等更适合做配置文件。YAML具体的语法规范可以参考官网 2.2.1 YAML 基本语法 使用缩进进行层级关系，键值对之间必须带空格 缩进时不允许使用 TAB 键，只允许 Space 即空格键 缩进空格数量不重要，相同层级元素左对齐即可。（约定俗成使用 2 个空格） 大小写敏感 2.2.2 支持三种数据结构 对象：键值对的集合，或者称为 MAP 数组：一组按次序排列的值 字面量：包括字符串，数字，布尔值和日期等 2.2.3 属性值注入例子以下我们通过 @ConfigurationProperties 和 @Value 分别实现从配置文件读取属性注入到程序中。 首先创建实体类 Person 和 Dog 123456789101112131415161718192021public class Dog &#123; private String name; private Integer age; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950@Component@ConfigurationProperties(prefix = \"person\")public class Person &#123; private String name; private Boolean isBoss; private Map&lt;String, Object&gt; map; private List&lt;Object&gt; list; private Dog dog; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Boolean getBoss() &#123; return isBoss; &#125; public void setBoss(Boolean boss) &#123; isBoss = boss; &#125; public Map&lt;String, Object&gt; getMap() &#123; return map; &#125; public void setMap(Map&lt;String, Object&gt; map) &#123; this.map = map; &#125; public List&lt;Object&gt; getList() &#123; return list; &#125; public void setList(List&lt;Object&gt; list) &#123; this.list = list; &#125; public Dog getDog() &#123; return dog; &#125; public void setDog(Dog dog) &#123; this.dog = dog; &#125;&#125; 在我们添加 @ConfigurationProperties 注解时，IDEA 智能提示我们尚未导入 spring-boot-configuration-processor 依赖。所以在 pom.xml 下加入 这里先以 properties 文件写入属性值 123456789101112server.port=8081server.servlet.context-path=/helloperson.name=张三person.boss=falseperson.birthday=1995/01/01person.map.k1=v1person.map.k2=100person.map.k3=trueperson.list=1,true,helloperson.dog.name=Rookieperson.dog.age=2 最后在 test 包下进行测试 123456789101112131415@RunWith(SpringRunner.class)@SpringBootTestpublic class ApplicationTests &#123; @Autowired private Person person; @Test public void contextLoads() &#123; System.out.println(person); &#125;&#125; debug 运行后得到如下结果 相应的 yml 格式如下 123456789person: name: 李四 boss: true birthday: 2000/1/1 map: &#123; k1: v1, k2: 100, k3: false &#125; list: 1, java, 你好, false dog: name: Tom age: 1 以上演示的是 list 的行内写法，缩进写法如下 12345list: - 1 - Java - 你好 - false 我们注意到 application.properties 或 application.yml 都是全局配置文件，person 应该写在一个独立的 person.properties 比较合适，所以我们新建一个 properties 文件，并且为 Person 加上一个注解 @PropertySource 指定资源路径 1234@Component@ConfigurationProperties(prefix = \"person\")@PropertySource(value = \"classpath:person.properties\") // 这里 person.yml 可以不？public class Person &#123;&#125; 然后测试一下 可以看到虽然属性值成功注入到 Person 组件了，但是从 properties 文件读取的值出现了中文乱码。这是由于 IDEA 使用 UTF-8 作为字符集，但是 properties 写入文件存的是 ASCII 编码，所以需要修改 IDEA properties 设置 重新编写 properties 文件，再次运行，发现乱码得到解决 我们也可以使用 @Value 注解实现属性值的注入 如果我们只是在某个业务逻辑中需要获取以下配置文件中的某项值，使用 @Value 就可以了，如果专门写了一个 JavaBean 来和配置文件映射，直接使用 @ConfigurationProperties 会方便很多。 2.3 多 Profile 文件我们在编写主配置文件时，文件名可以是 application-{profile}-properties/yml 默认使用的是 application.properties/yml 为了更方便的切换，我们可以使用 yml 的多文档块方式 — 1234567891011121314151617181920212223server: port: 8080 # 默认端口spring: profiles: active: dev # 激活开发环境 ---server: port: 8081spring: profiles: dev # 指定是开发环境 ---server: port: 8082spring: profiles: test # 指定是测试环境---server: port: 8083spring: profiles: prod # 指定是生产环境 三、加载顺序Spring Boot 启动会扫描以下位置的 application.properties 或者 application.yml 文件作为 Spring Boot 的默认配置文件： file:./config/ file:./ classpath:/config/ classpath:/ 以上是按照优先级从高到低的顺序，所有位置的文件都会被加载，高优先 级配置内容会覆盖低优先级配置内容。 我们也可以通过配置spring.config.location来改变默认配置。 以下我们通过简单例子来论证以上观点。 我们在四个文件都指定了 server port ，分别为 8081，8082，8083 和 8084，而最后生效的是 8081，这说明 Spring Boot 优先加载 file:./config 下的配置文件 四、配置原理1、可以查看HttpEncodingAutoConfiguration 2、通用模式 – xxxAutoConfiguration：自动配置类 – xxxProperties：属性配置类 – yml/properties文件中能配置的值就来源于[属性配置类] 3、几个重要注解 – @Bean – @Conditional 4、–debug=true 查看详细的自动配置报告 精髓 1）、Spring Boot 启动会加载大量的自动配置类 2）、我们看我们需要的功能有没有 Spring Boot 默认写好的自动配置类；3）、我们再来看这个自动配置类中到底配置了哪些组件；（只要我们要用的组件有，我们就不需要再来配置了） 4）、给容器中自动配置类添加组件的时候，会从 properties 类中获取某些属性。我们就可以在配置文件中指定这 些属性的值； @Conditional 扩展 @Conditional扩展注解 作用（判断是否满足当前指定条件） @ConditionalOnJava 系统的java版本是否符合要求 @ConditionalOnBean 容器中存在指定Bean @ConditionalOnMissingBean 容器中不存在指定Bean @ConditionalOnExpression 满足SpEL表达式指定 @ConditionalOnClass 系统中有指定的类 @ConditionalOnMissingClass 系统中没有指定的类 @ConditionalOnSingleCandidate 容器中只有一个指定的Bean，或者这个Bean是首选Bean @ConditionalOnProperty 系统中指定的属性是否有指定的值 @ConditionalOnResource 类路径下是否存在指定资源文件 @ConditionalOnWebApplication 当前是web环境 @ConditionalOnNotWebApplication 当前不是web环境 @ConditionalOnJndi JNDI存在指定项 五、本文 Demo占位符 六、参考文献 尚硅谷 Spring Boot 核心技术篇 官网","categories":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://calvinhwang123.github.io/categories/Spring-Boot/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://calvinhwang123.github.io/tags/Spring-Boot/"}]},{"title":"第一个 Spring Boot APP","slug":"first-spring-boot-application","date":"2018-11-28T16:00:00.000Z","updated":"2018-12-04T12:00:58.764Z","comments":true,"path":"2018/11/29/first-spring-boot-application/","link":"","permalink":"https://calvinhwang123.github.io/2018/11/29/first-spring-boot-application/","excerpt":"一、Spring Boot 简介1、产生背景Java EE 开发笨重、配置繁多、开发效率低下、部署流程复杂、第三方技术集成难度大","text":"一、Spring Boot 简介1、产生背景Java EE 开发笨重、配置繁多、开发效率低下、部署流程复杂、第三方技术集成难度大 2、解决方案 Spring 全家桶时代。通过 Spring MVC 处理控制层，Spring 事务管理处理业务层，Spring Data 处理持久层，Spring 拥有一套完整的企业级 Java WEB 应用开发的解决方案。 Spring Boot。目标是提供 Java EE 一站式解决方案。 Spring Cloud。目标是提供分布式整体解决方案。（微服务架构风格） 3、优势 快速创建独立运行的Spring项目以及与主流框架集成 –&gt; 各种 starter，暂且称为 场景启动器 使用嵌入式的Servlet容器（默认支持 Tomcat，Jetty 和 Undertow，也可自定义），应用无需打成WAR包（可以打成 jar 包并使用内置 WEB 容器运行） starters自动依赖与版本控制 大量的自动配置，简化开发，也可修改默认值 无需配置XML，无代码生成，开箱即用 准生产环境的运行时应用监控 – 与云计算的天然集成 4、拓展：微服务架构风格详见 微服务架构的倡导者 Martin Fowler 个人网站 微服务架构风格介绍 简而言之，微服务架构风格是将单个应用程序开发为一套小型服务的方法，每个小型服务都在自己的流程中运行，并与轻量级机制（通常是HTTP资源API）进行通信。这些服务围绕业务功能构建，可通过全自动部署机制独立部署。这些服务至少集中管理，可以用不同的编程语言编写，并使用不同的数据存储技术。——詹姆斯刘易斯和马丁福勒 In short, the microservice architectural style is an approach to developing a single application as a suite of small services, each running in its own process and communicating with lightweight mechanisms, often an HTTP resource API. These services are built around business capabilities and independently deployable by fully automated deployment machinery. There is a bare minimum of centralized management of these services, which may be written in different programming languages and use different data storage technologies. – James Lewis and Martin Fowler 5、总说Spring Boot 是 Pivotal 团队推出的 Java 开发框架。Spring Boot 使得开发者更轻易地开发出基于 Spring 的独立运行、生产级别的 WEB 应用。Spring Boot 为开发者整合了主流的第三方库，通过极少的配置，就能构建出一款企业级应用。 总的说，Spring Boot 是用来简化 Spring应用开发，本着 约定大于配置 的原则，去繁从简， just run as spring boot app ,就能创建一个独立的，产品级别的应用。 二、入门小 Demo1、开发环境 JDK 1.8 MAVEN 3.x IDEA 2017.2.2 或 STS 3.9.x Spring Boot 1.5.x 或 Spring Boot 2.1.0 Spring Boot 2.1.x 要求 JDK 1.8+，Spring 5.1.x+，Tomcat 9，可以根据实际情况选用 Spring Boot 1.5.x 或者 Spring Boot 2.1.x 2、IDEA 问个好 以下是基于个人喜好修改的几项 IDEA 配置，觉得有用的可以参考下 IDEA Preferences 首先是 New Project，前提是配置好了 Project SDK，即 JDK，并且保证在联网的环境下。 其次是填写 Project Metadata，我们选择 Maven 工程，IDEA 将为我们生成 pom.xml 文件构建 Maven 工程。使用 Java 开发，package 方式为 jar 包。package 包名如果觉得过长可以修改下。 然后选择我们要添加的 dependences。因为我们是 WEB 入门小 demo，所以选择 web 依赖即可。Spring Boot 版本可以根据自身需要选择 2.x 或者 1.5x。 最后是确认项目名称和项目路径，然后点 finish 完成。 以下是基于 IDEA MAVEN 构建的 Spring Boot 工程，如果略带强迫症的患者可以删除选中的几项无用配置文件 打开 pom.xml 文件，可以看到一个最简的 Spring Boot 引入了 starter-web 和 starter-test 两个依赖，还有一个 maven-plugin 插件（用于编译maven工程） 在 pom.xml 文件内部，右键 diagrams 可以查看项目依赖树 既然我们编写的是 WEB 应用，需要编写 controller 层处理客户端请求 1234567891011HelloController.java@RestControllerpublic class HelloController &#123; @GetMapping(&#123;&quot;/&quot;, &quot;/hello&quot;&#125;) public String greeting() &#123; return &quot;Hello Spring Boot&quot;; &#125;&#125; 可以看到 Spring Boot 已经为我们创建了一个形如 XXXApplication 的启动类，带有 @SpringBootApplication 注解，并且有一个 main 方法。 选择 IDEA main 方法左侧运行图标，以 run 方式启动 在 console 中除了看到 Spring Boot 绚丽的图标外，我们看到应用已经运行在内置的Tomcat 的 8080 端口上了。 最后是通过 Chrome 等浏览器访问 WEB 服务。可以看到 localhost:8080/ 和 localhost:8080/hello 被我们的 HelloController 处理了。 当然我们也可以使用 PostMan 工具模拟客户端请求，测试一下。 3、STS 问个好File / New / Spring Starter Project 填写好 project 相关信息，Next 还是选择 web dependency 就好，然后点击 finish 以下是 STS 构建的 Spring Boot 工程。 同样编写一个 HelloController 用于处理前端请求。 STS 运行 Spring Boot 应用的方式为：右键 Application 启动类，Run As / Spring Boot App。 在 console 上可以看到 应用已经运行起来了。 使用浏览器测试。 4、以 java -jar 方式运行以下以 IDEA 为例演示 Spring Boot Maven jar 工程的打包，cmd 方式运行 WEB 应用。 调出 Maven 面板 找到 compile ，双击它 compile 成功后，IEDA 在 target 目录下为我们生成了 project_name.jar 可执行 jar 包 右键它，选择面板中的 show in explorer，在 Windows 的资源管理器路径下输入 cmd 三个字母 最后在 cmd 下执行java -jar project_name.jar ，前提是停止了 IDEA 运行的 web 工程，否则会出现端口占用的问题。 由以上可见，我们使用 java -jar 命令也能在 cmd 上运行 jar 应用。 三、Spring Boot 入口类探究1、入口类程序从 main 方法开始执行，默认使用 SpringApplication.run() 加载主程序类 2、@SpringBootApplication实际上是个组合注解： 123456@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan(excludeFilters = &#123; @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class), @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)public @interface SpringBootApplication &#123;&#125; 2.1 @SpringBootConfiguration其中，@SpringBootConfiguration 表示是 Spring 底层配置类，如下： 12@Configurationpublic @interface SpringBootConfiguration &#123;&#125; 2.2 @ComponentScan@ComponentScan 是个组件扫描注解 2.3 @EnableAutoConfiguration@EnableAutoConfiguration 是一个核心注解，表示允许 Spring Boot 完成自动配置功能 123@AutoConfigurationPackage@Import(AutoConfigurationImportSelector.class)public @interface EnableAutoConfiguration &#123;&#125; 2.3.1 @AutoConfigurationPackage其中 @AutoConfigurationPackage 通过导入一个 AutoConfigurationPackages.Registrar 注册类为程序指定了自动配置的包范围 12@Import(AutoConfigurationPackages.Registrar.class)public @interface AutoConfigurationPackage &#123;&#125; 由此可见，程序启动会扫描加载主程序类所在的包以及子包。这说明如果一个包位于主程序类所在包之外，是不会被 Spring 容器扫描实例化的。以下是简单的例子： AnotherController 位于 com.shinedeer.springboot 包之外 通过浏览器访问 localhost:8080/another 请求，结果返回 404。 2.3.2 @Import(AutoConfigurationImportSelector.class)@Import 作用是导入所有自动配置场景 AutoConfigurationImportSelector 会给容器中导入非常多的自动配置类，形如 XXXAutoConfiguration ，就是给容器中导入 starter 需要的组件并进行配置。 四、相关 Demo 本文 Demo 占位符 Spring Boot Official Samples Github 五、参考文献 Spring Boot 官方 reference 官网 尚硅谷 Spring Boot 核心技术篇 官网 ​ ​","categories":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://calvinhwang123.github.io/categories/Spring-Boot/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://calvinhwang123.github.io/tags/Spring-Boot/"}]}]}